import xlrd,xlwt,os
print(os.getcwd()+'\\test.xlsx')
rb = xlrd.open_workbook(os.getcwd()+'\\test.xlsx')
sheet = rb.sheet_by_index(0)
val = sheet.row_values(0)[0]
vals = [sheet.row_values(rownum) for rownum in range(sheet.nrows)]
---------------------------------------------------------------------------------------------------------------------------------------------
НАХОЖДЕНИЕ СКВАЖИН,КОТОРЫЕ ИМЕЮТ МАКСИМАЛЬНУЮ ДОБЫЧУ ПО НЕФТИ, НО НЕ САДАПТИРОВАНЫ И ИХ СОРТИРОВКА
---------------------------------------------------------------------------------------------------------------------------------------------
MAIN = {'100', '101', '10106', '10107', '11700', '11701', '11919', '11920', '11921', '11921D', '11979', '11980', '11981', '11982', '11983', '11984', '11985', '11986', '11987', '11988', '12042', '12043', '12044', '12045', '12233', '12234', '12235', '12236', '12237', '12238', '12239', '12240', '12241', '12242', '13401', '13402', '13403', '13404', '13405', '13406', '13407', '13408', '13409', '13410', '13411', '13412', '13413', '13414', '13415', '13416', '13417', '13418', '13419', '13420', '13421', '13422', '13423', '13424', '13425', '13426', '13427', '13427D', '13428', '13429', '13430', '13431', '13432', '13433', '13434', '13435', '13436', '13437', '13438', '13439', '13440', '13441', '13442', '13444', '13445', '13446', '13448', '13449', '13450', '13451', '13452', '13453', '13454', '13455', '13456', '13457', '13458', '13458D', '13459', '13460', '13461', '13462', '13463', '13464', '13465', '13466', '13467', '13468', '13469', '13470', '13471', '13472', '13473', '13474', '13475', '13476', '13477', '13478', '13479', '13480', '13481', '13483', '13484', '13485', '13486', '13487', '13488', '13489', '13490', '13491', '13492', '13493', '13494', '13495', '13496', '13497', '13498', '13499', '13501', '13503', '13504', '13506', '13507', '13508', '13509', '13510', '13511', '13512', '13513', '13514', '13515', '13516', '13518', '13519', '13520', '13521', '13522', '13523', '13524', '13525', '13526', '13527', '13528', '13529', '13530', '13531', '13532', '13533', '13534', '13535', '13536', '13537', '13538', '13539', '13540', '13541', '13542', '13543', '13544', '13545', '13546', '13547', '13548', '13549', '13550', '13551', '13552', '13553', '13554', '13555', '13556', '13557', '13558', '13559', '13560', '13561', '13563', '13564', '13565', '13566', '13567', '13568', '13569', '13570', '13572', '13573', '13574', '13575', '13576', '13577', '13578', '13579', '13580', '13581', '13582', '13583', '13584', '13585', '13586', '13588', '13589', '13590', '13591', '13592', '13593', '13594', '13595', '13596', '13597', '13598', '13599', '13600', '15113', '15113D', '15114', '16304', '16336', '16482', '16526', '16529', '16530', '16537', '16539', '16540', '16541', '16544', '16547', '17419', '17483', '21292', '21440', '21493', '21502', '21503', '21504', '21505', '21506', '21507', '21508', '21509', '21510', '21511', '21512', '21513', '21514', '21515', '21516', '21517', '21519', '21520', '21521', '21522', '21523', '21524', '21525', '21526', '21527', '21528', '21529', '21530', '21531', '21532', '21533', '21535', '21536', '21537', '21538', '21539', '21540', '21541', '21542', '21543', '21544', '21545', '21546', '21547', '21548', '21550', '21551', '21552', '21553', '21555', '21556', '21557', '21558', '21559', '21560', '21561', '21562', '21563', '21564', '21565', '21566', '21567', '21568', '21569', '21570', '21571', '21572', '21573', '21575', '21576', '21577', '21578', '21579', '21580', '21581', '21582', '21583', '21584', '21587', '21588', '21589', '21590', '21591', '21592', '21593', '21594', '21595', '21596', '21598', '21599', '21600', '21601', '21602', '21603', '21604', '21607', '21608', '21611', '21612', '21614', '21615', '21616', '21617', '21618', '21619', '21620', '21621', '21622', '21625', '21626', '21627', '21629', '21630', '21632', '21633', '21634', '21635', '21636', '21637', '21638', '21640', '21641', '21642', '21643', '21645', '21646', '21647', '21648', '21650', '21651', '21652', '21653', '21654', '21655', '21656', '21658', '21659', '21660', '21661', '21662', '21663', '21664', '21665', '21666', '21667', '21668', '21671', '21672', '21673', '21674', '21675', '21678', '21679', '21680', '21681', '21682', '21683', '21684', '21684A', '21685', '21686', '21687', '21688', '21689', '21691', '21692', '21694', '21696', '21697', '21698', '21699', '21700', '21701', '21702', '21703', '21704', '21705', '21706', '21707', '21708', '21710', '21711', '21712', '21713', '21714', '21715', '21716', '21717', '21718', '21719', '21720', '21721', '21724', '21725', '21726', '21727', '21731', '21732', '21733', '21734', '21735', '21736', '21738', '21740', '21741', '21742', '21743', '21744', '21745', '21746', '21747', '21748', '21750', '21751', '21753', '21755', '21757', '21758', '21759', '21760', '21761', '21762', '21763', '21764', '21765', '21766', '21767', '21768', '21769', '21771', '21772', '21773', '21774', '21775', '21776', '21777', '21778', '21779', '21780', '21781', '21782', '21783', '21784', '21785', '21786', '21787', '21789', '21790', '21791', '21793', '21794', '21796', '21798', '21799', '21800', '25283', '25284', '25285', '25286', '25287', '25288', '25289', '25290', '25293', '25294', '25297', '25298', '25299', '25300', '27303', '27305', '27310', '27315', '27385', '27395', '27481', '27483', '27484', '27487', '32801', '32804', '32805', '32806', '32810', '32813', '32814', '32816', '32817', '32818', '32819', '32820', '32821', '32826', '32827', '32830', '32835', '32836', '32842', '32843', '32844', '32845', '32846', '32854', '32863', '32866', '32868', '32869', '32874', '32875', '32876', '32877', '32878', '32881', '32882', '32883', '32884', '32885', '32886', '32887', '32888', '32889', '32890', '32892', '32893', '32894', '32895', '32896', '32898', '32907', '32910', '32914', '32916', '32917', '32918', '32919', '32920', '32921', '32922', '32923', '32924', '32925', '32929', '32930', '32931', '32940', '32941', '32943', '32947', '32948', '32950', '32954', '32955', '32956', '32957', '32958', '32959', '32960', '3498', '3515', '3516', '3517', '3556', '3557', '3558', '3597', '48', '48D', '49', '5042', '51', '527', '53', '530', '54', '570', '571', '5712', '5713', '5714', '5715', '5716', '5717', '5718', '5719', '5719D', '572', '5720', '5721', '5722', '5722A', '5723', '5724', '5725', '5725A', '5726', '5727', '5728', '5728A', '5729', '5730', '5731', '5731A', '5732', '5733', '5734', '5735', '5736', '5737', '5738', '5739', '5740', '5741', '5741D', '5742', '5743', '5744', '5745', '5746', '5747', '5748', '5749', '5750', '5751', '58', '5801', '5802', '5803', '5804', '5805', '5806', '5806D', '5807', '5807D', '5808', '5809', '5810', '5811', '5811D', '5812', '5813', '5814', '5815', '5815D', '5816', '5816D', '5817', '5818', '5819', '5820', '5821', '5822', '5823', '5824', '5825', '5826', '5827', '5827D', '5828', '5829', '5830', '5831', '5832', '5833', '5834', '5835', '5836', '5837', '5838', '5839', '5840', '5840D', '5841', '5842', '5843', '5844', '5845', '5846', '5847', '5848', '5849', '5850', '5851', '5852', '5853', '5854', '5855', '5856', '5857', '5858', '5859', '5860', '5861', '5862', '5863', '5864', '5864D', '5865', '5865D', '5866', '5867', '5868', '5869', '5870', '5871', '5872', '5873', '5873D', '5874', '5875', '5876', '5877', '5878', '5879', '5880', '5881', '5882', '5883', '5884', '5884D', '5885', '5886', '5887', '5888', '5890', '5891', '5892', '5893', '5894', '5895', '5896', '5897', '5897D', '5898', '5899', '5900', '5901', '5902', '5902D', '5903', '5904', '5905', '5906', '5906D', '5907', '5907D', '5908', '5909', '5909D', '5910', '5911', '5912', '5913', '5913A', '5914', '5915', '5916', '5917', '5918', '5919', '5920', '5921', '5922', '5923', '5924', '5925', '5926', '5927', '5927D', '5928', '5928D', '5929', '5929D', '5930', '5930D', '5931', '5932', '5933', '5934', '5935', '5936', '5937', '5938', '5939', '5940', '5940D', '5941', '5941D', '5942', '5943', '5944', '5945', '5946', '5947', '5947D', '5948', '5949', '5950', '5951', '5952', '5953', '5954', '5955', '5955D', '5956', '5956D', '5957', '5958', '5959', '5960', '5961', '5962', '5963', '5964', '5965', '5966', '5967', '5968', '5969', '5970', '5971', '5972', '5973', '5974', '5975', '5976', '5977', '5978', '5979', '5980', '5981', '5982', '5983', '5984', '5985', '5986', '5987', '5988', '5991', '5992', '5993', '5994', '5995', '5996', '5997', '5998', '5999', '651', '652', '653', '7400', '7401', '7402', '77D', '8000', '8001', '8002', '8002D', '8003', '8004', '8005', '8006', '8007', '8008', '8008D', '8009', '8010', '8011', '8012', '8013', '8014', '8015', '8016', '8017', '8018', '8019', '8020', '8021', '8021D', '8022', '8022D', '8023', '8024', '8025', '8026', '8027', '8028', '8029', '8030', '8031', '8032', '8033', '8034', '8035', '8036', '8037', '8038', '8039', '8040', '8041', '8042', '8043', '8044', '8045', '8046', '8047', '8048', '8049', '8050', '8051', '8052', '8053', '8053B', '8054', '8055', '8056', '8057', '8058', '8059', '8060', '8061', '8062', '8063', '8064', '8065', '8066', '8067', '8068', '8069', '8070', '8071', '8072', '8073', '8074', '8075', '8076', '8077', '8078', '8079', '8080', '8081', '8081D', '8082', '8083', '8084', '8085', '8086', '8087', '8088', '8089', '8090', '8091', '8092', '8093', '8094', '8094D', '8095', '8096', '8097', '8098', '8099', '8100', '8101', '8102', '8103', '8104', '8106', '8107', '8108', '8109', '8110', '8111', '8112A', '8113', '8114', '8115', '8116', '8117', '8118', '8119', '8120', '8121', '8122', '8123', '8124', '8125', '8127', '8128', '8129', '8131', '8132', '8133', '8134', '8135', '8136', '8137', '8138', '8139', '8140', '8141', '8141D', '8142', '8143', '8144', '8145', '8146', '8147', '8148A', '8149', '8150', '8151', '8152', '8153', '8154', '8155', '8156', '8157', '8158', '8159', '8160', '8161', '8162', '8162D', '8163', '8164', '8165', '8166', '8167', '8168', '8168D', '8169', '8170', '8171', '8172', '8173', '8174', '8175', '8176', '8177', '8178', '8179', '8180', '8181', '8182', '8183', '8184', '8185', '8186', '8187', '8188', '8189', '8190', '8191', '8192', '8193', '8194', '8195', '8196', '8197', '8198', '8198D', '8199', '8200', '84', '84D'}
wells_number = 10 

prod_adapt = dict()
prod_adapt_set = set()

for m in get_all_models():
    for w in get_all_wells():
        well_set = set()
        well_set.add(w.name)
        if well_set & MAIN != set():
            cum_oil_hist = round(wopth[m,w].max(dates = 'all').to_list()[0],1)
            cum_oil = round(wopt[m,w].max(dates = 'all').to_list()[0],1)
            if cum_oil_hist > 0:
                adapt = abs(cum_oil_hist - cum_oil)*100/cum_oil_hist
                if adapt > 20:
                    prod_adapt[cum_oil_hist] = w.name
                
sorted_dict = sorted(prod_adapt)
for i in sorted_dict[-1:-1*wells_number-1:-1]:
    prod_adapt_set.add(prod_adapt[i])
    print(prod_adapt[i],i,sep='\t')

print(prod_adapt_set)

---------------------------------------------------------------------------------------------------------------------------------------------
ДЛЯ ФОРМАТИРОВАНИЯ ТРАССЕРА (выгрузка из TNavigator) СОЗДАНИЕ МУЛЬТОВ ДЛЯ АДАПТАЦИИ ГДМ ARR_CUT / ARR_PERF / ARR_MULT / ARR_OWC
---------------------------------------------------------------------------------------------------------------------------------------------
MODEL_OWC = {'1': '1494.0','2': '1486.5', '3': '1486.5'}
MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}
MODEL_ZONE = {'1','2','3'}
MAIN = {'100', '101', '10106', '10107', '11700', '11701', '11919', '11920', '11921', '11921D', '11979', '11980', '11981', '11982', '11983', '11984', '11985', '11986', '11987', '11988', '12042', '12043', '12044', '12045', '12233', '12234', '12235', '12236', '12237', '12238', '12239', '12240', '12241', '12242', '13401', '13402', '13403', '13404', '13405', '13406', '13407', '13408', '13409', '13410', '13411', '13412', '13413', '13414', '13415', '13416', '13417', '13418', '13419', '13420', '13421', '13422', '13423', '13424', '13425', '13426', '13427', '13427D', '13428', '13429', '13430', '13431', '13432', '13433', '13434', '13435', '13436', '13437', '13438', '13439', '13440', '13441', '13442', '13444', '13445', '13446', '13448', '13449', '13450', '13451', '13452', '13453', '13454', '13455', '13456', '13457', '13458', '13458D', '13459', '13460', '13461', '13462', '13463', '13464', '13465', '13466', '13467', '13468', '13469', '13470', '13471', '13472', '13473', '13474', '13475', '13476', '13477', '13478', '13479', '13480', '13481', '13483', '13484', '13485', '13486', '13487', '13488', '13489', '13490', '13491', '13492', '13493', '13494', '13495', '13496', '13497', '13498', '13499', '13501', '13503', '13504', '13506', '13507', '13508', '13509', '13510', '13511', '13512', '13513', '13514', '13515', '13516', '13518', '13519', '13520', '13521', '13522', '13523', '13524', '13525', '13526', '13527', '13528', '13529', '13530', '13531', '13532', '13533', '13534', '13535', '13536', '13537', '13538', '13539', '13540', '13541', '13542', '13543', '13544', '13545', '13546', '13547', '13548', '13549', '13550', '13551', '13552', '13553', '13554', '13555', '13556', '13557', '13558', '13559', '13560', '13561', '13563', '13564', '13565', '13566', '13567', '13568', '13569', '13570', '13572', '13573', '13574', '13575', '13576', '13577', '13578', '13579', '13580', '13581', '13582', '13583', '13584', '13585', '13586', '13588', '13589', '13590', '13591', '13592', '13593', '13594', '13595', '13596', '13597', '13598', '13599', '13600', '15113', '15113D', '15114', '16304', '16336', '16482', '16526', '16529', '16530', '16537', '16539', '16540', '16541', '16544', '16547', '17419', '17483', '21292', '21440', '21493', '21502', '21503', '21504', '21505', '21506', '21507', '21508', '21509', '21510', '21511', '21512', '21513', '21514', '21515', '21516', '21517', '21519', '21520', '21521', '21522', '21523', '21524', '21525', '21526', '21527', '21528', '21529', '21530', '21531', '21532', '21533', '21535', '21536', '21537', '21538', '21539', '21540', '21541', '21542', '21543', '21544', '21545', '21546', '21547', '21548', '21550', '21551', '21552', '21553', '21555', '21556', '21557', '21558', '21559', '21560', '21561', '21562', '21563', '21564', '21565', '21566', '21567', '21568', '21569', '21570', '21571', '21572', '21573', '21575', '21576', '21577', '21578', '21579', '21580', '21581', '21582', '21583', '21584', '21587', '21588', '21589', '21590', '21591', '21592', '21593', '21594', '21595', '21596', '21598', '21599', '21600', '21601', '21602', '21603', '21604', '21607', '21608', '21611', '21612', '21614', '21615', '21616', '21617', '21618', '21619', '21620', '21621', '21622', '21625', '21626', '21627', '21629', '21630', '21632', '21633', '21634', '21635', '21636', '21637', '21638', '21640', '21641', '21642', '21643', '21645', '21646', '21647', '21648', '21650', '21651', '21652', '21653', '21654', '21655', '21656', '21658', '21659', '21660', '21661', '21662', '21663', '21664', '21665', '21666', '21667', '21668', '21671', '21672', '21673', '21674', '21675', '21678', '21679', '21680', '21681', '21682', '21683', '21684', '21684A', '21685', '21686', '21687', '21688', '21689', '21691', '21692', '21694', '21696', '21697', '21698', '21699', '21700', '21701', '21702', '21703', '21704', '21705', '21706', '21707', '21708', '21710', '21711', '21712', '21713', '21714', '21715', '21716', '21717', '21718', '21719', '21720', '21721', '21724', '21725', '21726', '21727', '21731', '21732', '21733', '21734', '21735', '21736', '21738', '21740', '21741', '21742', '21743', '21744', '21745', '21746', '21747', '21748', '21750', '21751', '21753', '21755', '21757', '21758', '21759', '21760', '21761', '21762', '21763', '21764', '21765', '21766', '21767', '21768', '21769', '21771', '21772', '21773', '21774', '21775', '21776', '21777', '21778', '21779', '21780', '21781', '21782', '21783', '21784', '21785', '21786', '21787', '21789', '21790', '21791', '21793', '21794', '21796', '21798', '21799', '21800', '25283', '25284', '25285', '25286', '25287', '25288', '25289', '25290', '25293', '25294', '25297', '25298', '25299', '25300', '27303', '27305', '27310', '27315', '27385', '27395', '27481', '27483', '27484', '27487', '32801', '32804', '32805', '32806', '32810', '32813', '32814', '32816', '32817', '32818', '32819', '32820', '32821', '32826', '32827', '32830', '32835', '32836', '32842', '32843', '32844', '32845', '32846', '32854', '32863', '32866', '32868', '32869', '32874', '32875', '32876', '32877', '32878', '32881', '32882', '32883', '32884', '32885', '32886', '32887', '32888', '32889', '32890', '32892', '32893', '32894', '32895', '32896', '32898', '32907', '32910', '32914', '32916', '32917', '32918', '32919', '32920', '32921', '32922', '32923', '32924', '32925', '32929', '32930', '32931', '32940', '32941', '32943', '32947', '32948', '32950', '32954', '32955', '32956', '32957', '32958', '32959', '32960', '3498', '3515', '3516', '3517', '3556', '3557', '3558', '3597', '48', '48D', '49', '5042', '51', '527', '53', '530', '54', '570', '571', '5712', '5713', '5714', '5715', '5716', '5717', '5718', '5719', '5719D', '572', '5720', '5721', '5722', '5722A', '5723', '5724', '5725', '5725A', '5726', '5727', '5728', '5728A', '5729', '5730', '5731', '5731A', '5732', '5733', '5734', '5735', '5736', '5737', '5738', '5739', '5740', '5741', '5741D', '5742', '5743', '5744', '5745', '5746', '5747', '5748', '5749', '5750', '5751', '58', '5801', '5802', '5803', '5804', '5805', '5806', '5806D', '5807', '5807D', '5808', '5809', '5810', '5811', '5811D', '5812', '5813', '5814', '5815', '5815D', '5816', '5816D', '5817', '5818', '5819', '5820', '5821', '5822', '5823', '5824', '5825', '5826', '5827', '5827D', '5828', '5829', '5830', '5831', '5832', '5833', '5834', '5835', '5836', '5837', '5838', '5839', '5840', '5840D', '5841', '5842', '5843', '5844', '5845', '5846', '5847', '5848', '5849', '5850', '5851', '5852', '5853', '5854', '5855', '5856', '5857', '5858', '5859', '5860', '5861', '5862', '5863', '5864', '5864D', '5865', '5865D', '5866', '5867', '5868', '5869', '5870', '5871', '5872', '5873', '5873D', '5874', '5875', '5876', '5877', '5878', '5879', '5880', '5881', '5882', '5883', '5884', '5884D', '5885', '5886', '5887', '5888', '5890', '5891', '5892', '5893', '5894', '5895', '5896', '5897', '5897D', '5898', '5899', '5900', '5901', '5902', '5902D', '5903', '5904', '5905', '5906', '5906D', '5907', '5907D', '5908', '5909', '5909D', '5910', '5911', '5912', '5913', '5913A', '5914', '5915', '5916', '5917', '5918', '5919', '5920', '5921', '5922', '5923', '5924', '5925', '5926', '5927', '5927D', '5928', '5928D', '5929', '5929D', '5930', '5930D', '5931', '5932', '5933', '5934', '5935', '5936', '5937', '5938', '5939', '5940', '5940D', '5941', '5941D', '5942', '5943', '5944', '5945', '5946', '5947', '5947D', '5948', '5949', '5950', '5951', '5952', '5953', '5954', '5955', '5955D', '5956', '5956D', '5957', '5958', '5959', '5960', '5961', '5962', '5963', '5964', '5965', '5966', '5967', '5968', '5969', '5970', '5971', '5972', '5973', '5974', '5975', '5976', '5977', '5978', '5979', '5980', '5981', '5982', '5983', '5984', '5985', '5986', '5987', '5988', '5991', '5992', '5993', '5994', '5995', '5996', '5997', '5998', '5999', '651', '652', '653', '7400', '7401', '7402', '77D', '8000', '8001', '8002', '8002D', '8003', '8004', '8005', '8006', '8007', '8008', '8008D', '8009', '8010', '8011', '8012', '8013', '8014', '8015', '8016', '8017', '8018', '8019', '8020', '8021', '8021D', '8022', '8022D', '8023', '8024', '8025', '8026', '8027', '8028', '8029', '8030', '8031', '8032', '8033', '8034', '8035', '8036', '8037', '8038', '8039', '8040', '8041', '8042', '8043', '8044', '8045', '8046', '8047', '8048', '8049', '8050', '8051', '8052', '8053', '8053B', '8054', '8055', '8056', '8057', '8058', '8059', '8060', '8061', '8062', '8063', '8064', '8065', '8066', '8067', '8068', '8069', '8070', '8071', '8072', '8073', '8074', '8075', '8076', '8077', '8078', '8079', '8080', '8081', '8081D', '8082', '8083', '8084', '8085', '8086', '8087', '8088', '8089', '8090', '8091', '8092', '8093', '8094', '8094D', '8095', '8096', '8097', '8098', '8099', '8100', '8101', '8102', '8103', '8104', '8106', '8107', '8108', '8109', '8110', '8111', '8112A', '8113', '8114', '8115', '8116', '8117', '8118', '8119', '8120', '8121', '8122', '8123', '8124', '8125', '8127', '8128', '8129', '8131', '8132', '8133', '8134', '8135', '8136', '8137', '8138', '8139', '8140', '8141', '8141D', '8142', '8143', '8144', '8145', '8146', '8147', '8148A', '8149', '8150', '8151', '8152', '8153', '8154', '8155', '8156', '8157', '8158', '8159', '8160', '8161', '8162', '8162D', '8163', '8164', '8165', '8166', '8167', '8168', '8168D', '8169', '8170', '8171', '8172', '8173', '8174', '8175', '8176', '8177', '8178', '8179', '8180', '8181', '8182', '8183', '8184', '8185', '8186', '8187', '8188', '8189', '8190', '8191', '8192', '8193', '8194', '8195', '8196', '8197', '8198', '8198D', '8199', '8200', '84', '84D'}
'''
ФОРМАТИРОВАНИЕ ТРАССЕРА 0 СТУПЕНЬ (Удаление ненужных строк: "Трассер '... и ': Накопленная добыча, ст.м3")
ФОРМАТИРОВАНИЕ ТРАССЕРА 1 СТУПЕНЬ (Удаление ненужных строк: Обект Шаг Дата...)
tracer_1 -- НАКОПЛЕННАЯ ДОБЫЧА ТРАССЕРА НА ПОСЛЕДНИЮ ДАТУ
Объект	Шаг   Дата        Дней  A          B51       B54	
1000	788   01.03.2018  28    2.89E+03   0.00E+00  0.00E+00
Объект	Шаг   Дата        Дней  A          B51       B54
1003	788   01.03.2018  28    3.23E+04   0.00E+00  0.00E+00
'''
import re
tracer_model = open(get_project_folder()+'/skript/tracer/tracer_model.txt','r')
tracer = open(get_project_folder()+'/skript/tracer/tracer.txt','w')                                               
content = tracer_model.readlines()
for i in content:
#    print(i)
    i = re.sub('"РўСЂР°СЃСЃРµСЂ \'B','',i)
    i = re.sub('"РўСЂР°СЃСЃРµСЂ \'','',i)
    i = re.sub('\': РќР°РєРѕРїР»РµРЅРЅР°СЏ РґРѕР±С‹С‡Р°, СЃС‚.Рј3"','',i)
    i = re.sub('0.00000000e+00','0',i)
    i = i.strip()
    print(i,file=tracer)
    break
    
for i in range(len(content)):
    if i % 2 == 1:
        print(content[i],end='',file = tracer)

tracer_model.close()
tracer.close()

'''
ФОРМАТИРОВАНИЕ ТРАССЕРА 1 СТУПЕНЬ / СОЗДАНИЕ СЛОВОРЯ (накопленная добыча из трассера А, отношение добычи трассеров от нагнетательных скважин к трассеру А,трассеры по скважинам)
tracer
Объект	Шаг   Дата        Дней  A          51        54
1000	788   01.03.2018  28    2.89E+03   0.00E+00  0.00E+00
1003	788   01.03.2018  28    3.23E+04   0.00E+00  0.00E+00
tracer_PI
100	A	2.89E+03
100	B13584	1.59E+01
100	B13585	4.36E+02
100	B21735	1.31E+00
100	WAT_INJ_TR	453.2
'''
tracer = open(get_project_folder()+'/skript/tracer/tracer.txt','r')
tracer_PI = open(get_project_folder()+'/skript/tracer/tracer_PI.txt','w')
dict_well_trac_A = open(get_project_folder()+'/skript/dict/dict_well_trac_A.txt','w')                                       #{'СКВАЖИНА': 'ДОБЫЧА ОТ ТРАССЕРА А'}
dict_well_trac_RP = open(get_project_folder()+'/skript/dict/dict_well_trac_RP.txt','w')                                     #{'СКВАЖИНА': 'КАКАЯ ЧАСТЬ ДОБЫЧИ ВОДЫ ИДЕТ ОТ НАГНЕТАТЕЛЬНЫХ СКВАЖИН'}

content = tracer.readlines()
content_matrix = [[content[i].split('\t')[j] for j in range(len(content[i].split('\t')))] for i in range(len(content))]  

well_trac_A = dict()                                                                                                        #создание словоря добыча из трасса А
well_trac_RP = dict()                                                                                                       #создание словоря - отношение добычи трассера А к добыче из нагнетательных скважин (какая часть воды приходится на нагнетательные скважины )
for i in range(len(content)):
    if i != 0:
        sum_inj_tracer = 0                                                                                                  #переменная сумма добычи трассера
        print(content_matrix[i][0]+'\t'+content_matrix[0][4]+'\t'+str(round(float(content_matrix[i][4]),1)),file=tracer_PI)  #добыча трассера А
        print(content_matrix[i][0]+'\t'+content_matrix[0][4]+'\t'+str(round(float(content_matrix[i][4]),1)))
        dict_well_tracer = open(get_project_folder()+'/skript/tracer_prod/'+str(content_matrix[i][0])+'.txt','w')
        well_tracer = dict()
        for j in range(5,len(content_matrix[i])):                                                                           #проверка если добыча трассера не равна 0
            if float(content_matrix[i][j]) > 1:                                                                             #ислючаем трассеры с 0 и с маленькими значением (3E-7)
                print(content_matrix[i][0]+'\t'+content_matrix[0][j].strip()+'\t'+str(round(float(content_matrix[i][j]),1)),file=tracer_PI)
                print(content_matrix[i][0]+'\t'+content_matrix[0][j].strip()+'\t'+str(round(float(content_matrix[i][j]),1)))
                well_tracer[content_matrix[0][j].strip()] = float(content_matrix[i][j])
                sum_inj_tracer = sum_inj_tracer + float(content_matrix[i][j])
        print(content_matrix[i][0]+'\t'+'INJ'+'\t'+str(round(sum_inj_tracer,1)))
        print(str(content_matrix[i][0])+'\t'+'INJ'+'\t'+str(round(sum_inj_tracer,1)),file=tracer_PI)   
        print(well_tracer,file=dict_well_tracer)
        dict_well_tracer.close()
        well_trac_A[content_matrix[i][0]] = round(float(content_matrix[i][4]),1)
        if float(content_matrix[i][4]) != 0:
            well_trac_RP[str(content_matrix[i][0])] = str(round(sum_inj_tracer/(float(content_matrix[i][4])+sum_inj_tracer),3))     #относительная добыча трассера от нагнетательных скважин
            print(content_matrix[i][0],'INJ/TOTAL',well_trac_RP[str(content_matrix[i][0])],'\n',sep='\t')
            print(content_matrix[i][0],'INJ/TOTAL',well_trac_RP[str(content_matrix[i][0])],'\n',sep='\t',file=tracer_PI)
        else:
            well_trac_RP[content_matrix[i][0]] = 0
print(well_trac_A,file=dict_well_trac_A)
print(well_trac_RP,file=dict_well_trac_RP)
tracer.close()
tracer_PI.close()
dict_well_trac_A.close()
dict_well_trac_RP.close()

'''
СОЗДАНИЕ СЛОВОРЯ  - трассер от нагнетательной скважины
'''
tracer = open(get_project_folder()+'/skript/tracer/tracer.txt','r')

content = tracer.readlines()
content_matrix = [[content[i].split('\t')[j] for j in range(len(content[i].split('\t')))] for i in range(len(content))]  

for i in range(5,len(content_matrix[0])):
    dict_tracer_inj = dict()
    try:
        tracer_inj = open(get_project_folder()+'/skript/tracer_inj/'+str(content_matrix[0][i])+'.txt','w')
    except OSError:
        tracer_inj = open(get_project_folder()+'/skript/tracer_inj/'+str(content_matrix[0][i])[:-1]+'.txt','w')
    for j in range(len(content)):
        if j != 0:
            if float(content_matrix[j][i]) > 1 and j != 0:
                dict_tracer_inj[str(content_matrix[j][0])] = str(round(float(content_matrix[j][i]),1))
    print(dict_tracer_inj,file=tracer_inj)
    tracer_inj.close()
    
tracer.close()

'''
СОЗДАНИЕ СЛОВОРЯ - (какая разница в накопленных отборах воды и накопленная добыча воды)/(какая разница в накопленных отборах нефти и накопленная добыча нефти)
'''

dict_well_ROP = open(get_project_folder()+'/skript/dict/dict_well_ROP.txt','w')                                             #{'СКВАЖИНА': 'СУММАРНАЯ ДОБЫЧА НЕФТИ ПО РАСЧЕТУ К СУММАРНОЙ ДОБЫЧЕ НЕФТИ ПО ИСТОРИИ'}
well_ROP = dict()                                                                                                           # словарь отношение истории к расчету добычи нефти
for m in get_all_models():
    if float(FLPTH[m].max(dates='all').to_list()[0]) > 0:
        for w in get_all_wells():
            OPH = WOPTH[m,w].max(dates='all')
            OP = WOPT[m,w].max(dates='all')
            ROP = round((OP/OPH).to_list()[0],3)
            well_ROP[w.name] = str(ROP)
print(well_ROP,file=dict_well_ROP)

dict_well_ROP.close()
'''
ОГРАНИЧЕНИЕ ЗАКАЧКИ - ARR_CUT
'''
MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}
MAIN = {'100', '101', '10106', '10107', '11700', '11701', '11919', '11920', '11921', '11921D', '11979', '11980', '11981', '11982', '11983', '11984', '11985', '11986', '11987', '11988', '12042', '12043', '12044', '12045', '12233', '12234', '12235', '12236', '12237', '12238', '12239', '12240', '12241', '12242', '13401', '13402', '13403', '13404', '13405', '13406', '13407', '13408', '13409', '13410', '13411', '13412', '13413', '13414', '13415', '13416', '13417', '13418', '13419', '13420', '13421', '13422', '13423', '13424', '13425', '13426', '13427', '13427D', '13428', '13429', '13430', '13431', '13432', '13433', '13434', '13435', '13436', '13437', '13438', '13439', '13440', '13441', '13442', '13444', '13445', '13446', '13448', '13449', '13450', '13451', '13452', '13453', '13454', '13455', '13456', '13457', '13458', '13458D', '13459', '13460', '13461', '13462', '13463', '13464', '13465', '13466', '13467', '13468', '13469', '13470', '13471', '13472', '13473', '13474', '13475', '13476', '13477', '13478', '13479', '13480', '13481', '13483', '13484', '13485', '13486', '13487', '13488', '13489', '13490', '13491', '13492', '13493', '13494', '13495', '13496', '13497', '13498', '13499', '13501', '13503', '13504', '13506', '13507', '13508', '13509', '13510', '13511', '13512', '13513', '13514', '13515', '13516', '13518', '13519', '13520', '13521', '13522', '13523', '13524', '13525', '13526', '13527', '13528', '13529', '13530', '13531', '13532', '13533', '13534', '13535', '13536', '13537', '13538', '13539', '13540', '13541', '13542', '13543', '13544', '13545', '13546', '13547', '13548', '13549', '13550', '13551', '13552', '13553', '13554', '13555', '13556', '13557', '13558', '13559', '13560', '13561', '13563', '13564', '13565', '13566', '13567', '13568', '13569', '13570', '13572', '13573', '13574', '13575', '13576', '13577', '13578', '13579', '13580', '13581', '13582', '13583', '13584', '13585', '13586', '13588', '13589', '13590', '13591', '13592', '13593', '13594', '13595', '13596', '13597', '13598', '13599', '13600', '15113', '15113D', '15114', '16304', '16336', '16482', '16526', '16529', '16530', '16537', '16539', '16540', '16541', '16544', '16547', '17419', '17483', '21292', '21440', '21493', '21502', '21503', '21504', '21505', '21506', '21507', '21508', '21509', '21510', '21511', '21512', '21513', '21514', '21515', '21516', '21517', '21519', '21520', '21521', '21522', '21523', '21524', '21525', '21526', '21527', '21528', '21529', '21530', '21531', '21532', '21533', '21535', '21536', '21537', '21538', '21539', '21540', '21541', '21542', '21543', '21544', '21545', '21546', '21547', '21548', '21550', '21551', '21552', '21553', '21555', '21556', '21557', '21558', '21559', '21560', '21561', '21562', '21563', '21564', '21565', '21566', '21567', '21568', '21569', '21570', '21571', '21572', '21573', '21575', '21576', '21577', '21578', '21579', '21580', '21581', '21582', '21583', '21584', '21587', '21588', '21589', '21590', '21591', '21592', '21593', '21594', '21595', '21596', '21598', '21599', '21600', '21601', '21602', '21603', '21604', '21607', '21608', '21611', '21612', '21614', '21615', '21616', '21617', '21618', '21619', '21620', '21621', '21622', '21625', '21626', '21627', '21629', '21630', '21632', '21633', '21634', '21635', '21636', '21637', '21638', '21640', '21641', '21642', '21643', '21645', '21646', '21647', '21648', '21650', '21651', '21652', '21653', '21654', '21655', '21656', '21658', '21659', '21660', '21661', '21662', '21663', '21664', '21665', '21666', '21667', '21668', '21671', '21672', '21673', '21674', '21675', '21678', '21679', '21680', '21681', '21682', '21683', '21684', '21684A', '21685', '21686', '21687', '21688', '21689', '21691', '21692', '21694', '21696', '21697', '21698', '21699', '21700', '21701', '21702', '21703', '21704', '21705', '21706', '21707', '21708', '21710', '21711', '21712', '21713', '21714', '21715', '21716', '21717', '21718', '21719', '21720', '21721', '21724', '21725', '21726', '21727', '21731', '21732', '21733', '21734', '21735', '21736', '21738', '21740', '21741', '21742', '21743', '21744', '21745', '21746', '21747', '21748', '21750', '21751', '21753', '21755', '21757', '21758', '21759', '21760', '21761', '21762', '21763', '21764', '21765', '21766', '21767', '21768', '21769', '21771', '21772', '21773', '21774', '21775', '21776', '21777', '21778', '21779', '21780', '21781', '21782', '21783', '21784', '21785', '21786', '21787', '21789', '21790', '21791', '21793', '21794', '21796', '21798', '21799', '21800', '25283', '25284', '25285', '25286', '25287', '25288', '25289', '25290', '25293', '25294', '25297', '25298', '25299', '25300', '27303', '27305', '27310', '27315', '27385', '27395', '27481', '27483', '27484', '27487', '32801', '32804', '32805', '32806', '32810', '32813', '32814', '32816', '32817', '32818', '32819', '32820', '32821', '32826', '32827', '32830', '32835', '32836', '32842', '32843', '32844', '32845', '32846', '32854', '32863', '32866', '32868', '32869', '32874', '32875', '32876', '32877', '32878', '32881', '32882', '32883', '32884', '32885', '32886', '32887', '32888', '32889', '32890', '32892', '32893', '32894', '32895', '32896', '32898', '32907', '32910', '32914', '32916', '32917', '32918', '32919', '32920', '32921', '32922', '32923', '32924', '32925', '32929', '32930', '32931', '32940', '32941', '32943', '32947', '32948', '32950', '32954', '32955', '32956', '32957', '32958', '32959', '32960', '3498', '3515', '3516', '3517', '3556', '3557', '3558', '3597', '48', '48D', '49', '5042', '51', '527', '53', '530', '54', '570', '571', '5712', '5713', '5714', '5715', '5716', '5717', '5718', '5719', '5719D', '572', '5720', '5721', '5722', '5722A', '5723', '5724', '5725', '5725A', '5726', '5727', '5728', '5728A', '5729', '5730', '5731', '5731A', '5732', '5733', '5734', '5735', '5736', '5737', '5738', '5739', '5740', '5741', '5741D', '5742', '5743', '5744', '5745', '5746', '5747', '5748', '5749', '5750', '5751', '58', '5801', '5802', '5803', '5804', '5805', '5806', '5806D', '5807', '5807D', '5808', '5809', '5810', '5811', '5811D', '5812', '5813', '5814', '5815', '5815D', '5816', '5816D', '5817', '5818', '5819', '5820', '5821', '5822', '5823', '5824', '5825', '5826', '5827', '5827D', '5828', '5829', '5830', '5831', '5832', '5833', '5834', '5835', '5836', '5837', '5838', '5839', '5840', '5840D', '5841', '5842', '5843', '5844', '5845', '5846', '5847', '5848', '5849', '5850', '5851', '5852', '5853', '5854', '5855', '5856', '5857', '5858', '5859', '5860', '5861', '5862', '5863', '5864', '5864D', '5865', '5865D', '5866', '5867', '5868', '5869', '5870', '5871', '5872', '5873', '5873D', '5874', '5875', '5876', '5877', '5878', '5879', '5880', '5881', '5882', '5883', '5884', '5884D', '5885', '5886', '5887', '5888', '5890', '5891', '5892', '5893', '5894', '5895', '5896', '5897', '5897D', '5898', '5899', '5900', '5901', '5902', '5902D', '5903', '5904', '5905', '5906', '5906D', '5907', '5907D', '5908', '5909', '5909D', '5910', '5911', '5912', '5913', '5913A', '5914', '5915', '5916', '5917', '5918', '5919', '5920', '5921', '5922', '5923', '5924', '5925', '5926', '5927', '5927D', '5928', '5928D', '5929', '5929D', '5930', '5930D', '5931', '5932', '5933', '5934', '5935', '5936', '5937', '5938', '5939', '5940', '5940D', '5941', '5941D', '5942', '5943', '5944', '5945', '5946', '5947', '5947D', '5948', '5949', '5950', '5951', '5952', '5953', '5954', '5955', '5955D', '5956', '5956D', '5957', '5958', '5959', '5960', '5961', '5962', '5963', '5964', '5965', '5966', '5967', '5968', '5969', '5970', '5971', '5972', '5973', '5974', '5975', '5976', '5977', '5978', '5979', '5980', '5981', '5982', '5983', '5984', '5985', '5986', '5987', '5988', '5991', '5992', '5993', '5994', '5995', '5996', '5997', '5998', '5999', '651', '652', '653', '7400', '7401', '7402', '77D', '8000', '8001', '8002', '8002D', '8003', '8004', '8005', '8006', '8007', '8008', '8008D', '8009', '8010', '8011', '8012', '8013', '8014', '8015', '8016', '8017', '8018', '8019', '8020', '8021', '8021D', '8022', '8022D', '8023', '8024', '8025', '8026', '8027', '8028', '8029', '8030', '8031', '8032', '8033', '8034', '8035', '8036', '8037', '8038', '8039', '8040', '8041', '8042', '8043', '8044', '8045', '8046', '8047', '8048', '8049', '8050', '8051', '8052', '8053', '8053B', '8054', '8055', '8056', '8057', '8058', '8059', '8060', '8061', '8062', '8063', '8064', '8065', '8066', '8067', '8068', '8069', '8070', '8071', '8072', '8073', '8074', '8075', '8076', '8077', '8078', '8079', '8080', '8081', '8081D', '8082', '8083', '8084', '8085', '8086', '8087', '8088', '8089', '8090', '8091', '8092', '8093', '8094', '8094D', '8095', '8096', '8097', '8098', '8099', '8100', '8101', '8102', '8103', '8104', '8106', '8107', '8108', '8109', '8110', '8111', '8112A', '8113', '8114', '8115', '8116', '8117', '8118', '8119', '8120', '8121', '8122', '8123', '8124', '8125', '8127', '8128', '8129', '8131', '8132', '8133', '8134', '8135', '8136', '8137', '8138', '8139', '8140', '8141', '8141D', '8142', '8143', '8144', '8145', '8146', '8147', '8148A', '8149', '8150', '8151', '8152', '8153', '8154', '8155', '8156', '8157', '8158', '8159', '8160', '8161', '8162', '8162D', '8163', '8164', '8165', '8166', '8167', '8168', '8168D', '8169', '8170', '8171', '8172', '8173', '8174', '8175', '8176', '8177', '8178', '8179', '8180', '8181', '8182', '8183', '8184', '8185', '8186', '8187', '8188', '8189', '8190', '8191', '8192', '8193', '8194', '8195', '8196', '8197', '8198', '8198D', '8199', '8200', '84', '84D'}
#rel_arr_cut = 5                    # БЫЛО 5
diff_arr_cut = 5                   # БЫЛО 1
min_mult = 0.3
m_t = 5                             #мульт для трассера 2-5

from math import sqrt
from datetime import datetime
ARR_CUT = open(get_project_folder()+'/skript/ARR_CUT.txt','w')
arr_cut_dict_file = open(get_project_folder()+'/skript/dict/arr_cut_dict.txt','w')
dict_well_picks = open(get_project_folder()+'/skript/dict/dict_well_picks.txt','r')
dict_well_trac_A=open(get_project_folder()+'/skript/dict/dict_well_trac_A.txt','r')
dict_well_perf = open(get_project_folder()+'/skript/dict/dict_well_perf.txt','r')
#dict_res_pressure_file = open(get_project_folder()+'/skript/dict/dict_res_pressure.txt','r')            #АДАПТАЦИЯ ДЕПРЕССИИ/ПЛАСТОВОГО ДАВЛЕНИЯ (за весь период)
dict_prod_working_date_file = open(get_project_folder()+'/skript/dict/dict_prod_working_date.txt','r')
dict_inj_working_date_file = open(get_project_folder()+'/skript/dict/dict_inj_working_date.txt','r')

well_picks = eval(dict_well_picks.read())
well_trac_A = eval(dict_well_trac_A.read())
well_perf = eval(dict_well_perf.read())
dict_prod_working_date = eval(dict_prod_working_date_file.read())
dict_inj_working_date = eval(dict_inj_working_date_file.read())
#dict_res_pressure = eval(dict_res_pressure_file.read())
print('EQUALS\n',file=ARR_CUT)

arr_cut_dict = dict()
#prod_press_dict = dict()
#ROP_dict_summary = dict()
ROP_tracer_press = dict()

RP_h_interp = graph (type = 'well', default_value = 0)
BHP_h_interp = graph (type = 'well', default_value = 0)
for m in get_all_models():
    for w in get_all_wells():
        RP_h_list = []
        BHP_h_list = []
        t1 = c1 = 0
        Press_c_prod_list = []
        Press_c_inj_list = []
        Press_h_prod_list = []
        Press_h_inj_list = []
        avg_res_press_c_list = []
        avg_res_press_h_list = []
        if True:
            for t in get_all_timesteps():
                RP_h = round(wthph[m,w,t].to_list()[0],1)
                RP_c = round(wbp9[m,w,t].to_list()[0],1)
                BHP_h = round(wbhph[m,w,t].to_list()[0],1)
                BHP_c = round(wbhp[m,w,t].to_list()[0],1)
                if RP_h > 0:
                    RP_h_list.append((t.to_datetime(),RP_h))
                    if c1 == 0:
                        c1 = 1
                        t1 = datetime.strptime(t.name, "%d.%m.%Y")
                if BHP_h > 0:
                    BHP_h_list.append((t.to_datetime(),BHP_h))
                    if c1 == 0:
                        c1 = 1
                        t1 = datetime.strptime(t.name, "%d.%m.%Y")
            if len(RP_h_list) > 2:
                RP_h_interp[m,w] = create_table_vs_time(RP_h_list)
            if len(BHP_h_list) > 2:
                BHP_h_interp[m,w] = create_table_vs_time(BHP_h_list)
            for t in get_all_timesteps():
                try:
                    if datetime.strptime(t.name, "%d.%m.%Y") < t1:
                        BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
                except TypeError:
                    pass
                if wlprh[m,w,t] == 0 and wwirh[m,w,t] == 0:
                    BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
                else:
                    if BHP_h_interp[m,w,t] > RP_h_interp[m,w,t] and wlprh[m,w,t] > 0:
                        BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
                    if BHP_h_interp[m,w,t] < RP_h_interp[m,w,t] and wwirh[m,w,t] > 0:
                        BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0

def check_pressure(i_w,p_w):
    well_rp_c_dict = dict()
    well_rp_h_dict = dict()
    for m in get_all_models():
        first_date = datetime.strptime(dict_inj_working_date[i_w].split(',')[0], "%d.%m.%Y")
        last_date = datetime.strptime(dict_inj_working_date[i_w].split(',')[1], "%d.%m.%Y")
#        print(i_w,p_w,'Давление за период_1: '+first_date.strftime("%d.%m.%Y")+' - '+last_date.strftime("%d.%m.%Y"),sep='\t')
        for w in get_wells_by_mask(p_w):  
            for t in get_all_timesteps():            
                if RP_h_interp[m,w,t] != 0:
                    if wlprh[m,w,t] > 0:                           
                        cur_date = datetime.strptime(t.name, "%d.%m.%Y")                                                   
                        if first_date <= cur_date <= last_date:
                            try:
                                well_rp_h_dict[w.name] = well_rp_h_dict[w.name] + RP_h_interp[m,w,t].to_list()[0]
                            except KeyError:
                                well_rp_h_dict[w.name] = RP_h_interp[m,w,t].to_list()[0]
                            try:
                                well_rp_c_dict[w.name] = well_rp_c_dict[w.name] + wbp9[m,w,t].to_list()[0]
                            except KeyError:
                                well_rp_c_dict[w.name] = wbp9[m,w,t].to_list()[0]
        try:
            avr_pres = round(well_rp_c_dict[w.name]/well_rp_h_dict[w.name],2)
            print(i_w,w.name,'Давление за период_2: '+first_date.strftime("%d.%m.%Y")+'-'+last_date.strftime("%d.%m.%Y"),avr_pres,sep='\t')               #запись отношения пластового давления по скважиннам за период времени 
            return avr_pres
        except KeyError:
            pass                 
    
def dif_oil_prod(p_w):
    for m in get_all_models():
        for w in get_wells_by_mask(p_w):  
            oph = wopth[m,w].max(dates='all').to_list()[0]
            opc = wopt[m,w].max(dates='all').to_list()[0]
            return round(abs(opc-oph)/1000)
    

def fun_arr_cut(i_w):
#    print(eval('(k_mult_dif_oil_{})'.format(w.name)),file=ARR_CUT)
    k_mult_dif_oil_well = round(eval('sum(k_mult_dif_oil_{})'.format(w.name)),1)
    k_mult_tracer_well = round(eval('sum(k_mult_tracer_{})'.format(i_w)),2)
    if eval('len(mult_tracer_{})'.format(i_w)) != 0:
        mult_tracer_well = round(eval('sum(mult_tracer_{})/len(mult_tracer_{})'.format(i_w,i_w)),2)
    else:
        mult_tracer_well = 1
    prod_press = [i for i in eval('prod_press_{}'.format(i_w)) if i != None]
    if len(prod_press) != 0:
        press_mult = round(sum(prod_press)/len(prod_press),2)
    else:
        press_mult = 1
        
    if k_mult_dif_oil_well < -1*diff_arr_cut and sum_trac > 0.1:
#    if sum_mult_1/rel_arr_cut > sum_mult_2 and abs(sum_mult_1-sum_mult_2)+1 > diff_arr_cut and sum_trac > 0.1:
        mult = round((1/abs(k_mult_dif_oil_well-1))**(1/3),2)
#        mult = round((1/(sum_mult_1-sum_mult_2+1))**(1/3),2)
        for k,v in MODEL_CELLS.items():
            if set(k) & set(well_perf[i_w]) != set():
                print('ARR_CUT',mult,x,x,y,y,int(v.split(',')[0]),int(v.split(',')[1]),'/ -- {} {}-{} DOWN МАХ ДАВЛЕНИЕ: {} / ЗАКАЧКА: {} / TOTAL:mult1_mult2_tracer_press: {};{};{};{} mult_ROP_tracer_press: {}'.format(str(i_w),dict_inj_working_date[i_w].split(',')[0][-7:],dict_inj_working_date[i_w].split(',')[1][-7:],float(BHP),round(float(RI),2),k_mult_dif_oil_well,k_mult_tracer_well,mult_tracer_well,press_mult,ROP_tracer_press[w.name]),sep='\t')
                print('ARR_CUT',mult,x,x,y,y,int(v.split(',')[0]),int(v.split(',')[1]),'/ -- {} {}-{} DOWN МАХ ДАВЛЕНИЕ: {} / ЗАКАЧКА: {} / TOTAL:mult1_mult2_tracer_press: {};{};{};{} mult_ROP_tracer_press: {}'.format(str(i_w),dict_inj_working_date[i_w].split(',')[0][-7:],dict_inj_working_date[i_w].split(',')[1][-7:],float(BHP),round(float(RI),2),k_mult_dif_oil_well,k_mult_tracer_well,mult_tracer_well,press_mult,ROP_tracer_press[w.name]),sep='\t',file=ARR_CUT)
                if mult < min_mult:
                    mult = min_mult
                arr_cut_dict[i_w] = mult
            else:
                pass
#        print(w.name,RI,BHP,round(sum_trac,1),round(sum_mult_1,2),round(sum_mult_2,2),start_inj_date(w.name),'DOWN',sep='\t')
#        print(w.name,start_inj_date(w.name),'PERF','4*',mult,'-- DOWN / МАХ ДАВЛЕНИЕ: %d / ЗАКАЧКА: %.2f / delt: %.2f' %(BHP,RI,sum_mult_1-sum_mult_2+1),sep='\t')

#    elif k_mult_dif_oil_well > diff_arr_cut and RI < 0.95 and sum_trac > 0.1:      
##    elif sum_mult_2/rel_arr_cut > sum_mult_1 and abs(sum_mult_1-sum_mult_2)+1 > diff_arr_cut and RI < 0.98 and sum_trac > 0.1:
#        mult = round((k_mult_dif_oil_well+1)**(1/3),2)
##        mult = round((-sum_mult_1+sum_mult_2+1)**(1/3),2)
#        for k,v in MODEL_CELLS.items():
#            if set(k) & set(well_perf[i_w]) != set():
#                print('ARR_CUT',mult,x,x,y,y,int(v.split(',')[0]),int(v.split(',')[1]),'/ -- {} {}-{} UP МАХ ДАВЛЕНИЕ: {} / ЗАКАЧКА: {} / TOTAL:mult1_mult2_tracer_press: {};{};{};{} mult_ROP_tracer_press: {}'.format(str(i_w),dict_inj_working_date[i_w].split(',')[0][-7:],dict_inj_working_date[i_w].split(',')[1][-7:],float(BHP),round(float(RI),2),k_mult_dif_oil_well,k_mult_tracer_well,mult_tracer_well,press_mult,ROP_tracer_press[w.name]),sep='\t')
#                print('ARR_CUT',mult,x,x,y,y,int(v.split(',')[0]),int(v.split(',')[1]),'/ -- {} {}-{} UP МАХ ДАВЛЕНИЕ: {} / ЗАКАЧКА: {} / TOTAL:mult1_mult2_tracer_press: {};{};{};{} mult_ROP_tracer_press: {}'.format(str(i_w),dict_inj_working_date[i_w].split(',')[0][-7:],dict_inj_working_date[i_w].split(',')[1][-7:],float(BHP),round(float(RI),2),k_mult_dif_oil_well,k_mult_tracer_well,mult_tracer_well,press_mult,ROP_tracer_press[w.name]),sep='\t',file=ARR_CUT)
#                arr_cut_dict[i_w] = mult
#            else:
#                pass

#        print(w.name,RI,BHP,round(sum_trac,1),start_inj_date(w.name),'UP',sep='\t')
#        print(w.name,start_inj_date(w.name),'PERF','4*',mult,'-- UP / МАХ ДАВЛЕНИЕ: %d / ЗАКАЧКА: %.2f / delt: %.2f' %(BHP,RI,sum_mult_2-sum_mult_1+1),sep='\t')
    else:
        print(w.name,RI,BHP,round(sum_trac,1),start_inj_date(w.name),'NO_ACTION',sep='\t')

def start_inj_date(i_w):
    for i_w in get_wells_by_mask(i_w):
        for t in get_all_timesteps():
            if float(wwirh[m,i_w,t].to_list()[0]) > 0:
                return t.name

for m in get_all_models():
    if float(FLPTH[m].max(dates='all').to_list()[0]) > 0:
        ROP_dict = dict()
        for w in get_all_wells():
            cum_oil_hist = round(wopth[m,w].max(dates = 'all').to_list()[0],1)
            cum_oil = round(wopt[m,w].max(dates = 'all').to_list()[0],1)
            if cum_oil_hist > 0:
                ROP = cum_oil/cum_oil_hist
                ROP_dict[w.name] = round(ROP,2)
            
for m in get_all_models():
    if float(FLPTH[m].max(dates='all').to_list()[0]) > 0:
        for w in get_all_wells():
            try:
                exec('prod_press_{}=[]'.format(w.name))
                exec('mult_tracer_{}=[]'.format(w.name))
                exec('k_mult_tracer_{}=[]'.format(w.name))
                exec('k_mult_dif_oil_{}=[]'.format(w.name))
#                ROP_dict_summary[w.name] = ''
                ROP_tracer_press[w.name] = ''
                x = well_picks[str(w.name)].split(' ')[0]
                y = well_picks[str(w.name)].split(' ')[1]
                tracer_inj = open(get_project_folder()+'/skript/tracer_inj/'+str(w.name)+'.txt','r')
                dict_tracer_inj = eval(tracer_inj.read())
                cum_inj_hist = round(float(wwith[m,w].max(dates = 'all')),1)   
                cum_inj = round(float(wwit[m,w].max(dates = 'all')),1)   
                if cum_inj_hist > 0:
                    RI = round(cum_inj/cum_inj_hist,2)
                else:
                    RI = 0
                sum_trac = 0
#                sum_mult_1 = sum_mult_2 = sum_trac = 0
                BHP = round(float(WBHPT[m,w].max(dates='all')))
                for key, val in dict_tracer_inj.items():
                    well = set()
                    well.add(key)
                    if float(val) > 1:
                        dict_well_tracer = open(get_project_folder()+'/skript/tracer_prod/'+str(key)+'.txt','r')
                        well_tracer = eval(dict_well_tracer.read())
                        total_tracer = 0
                        for key_i, val_i in well_tracer.items():
                            total_tracer = total_tracer + float(val_i)
                        RP_Of_Tracer = round(float(well_tracer[w.name])/(total_tracer + float(well_trac_A[key])),3)
                        x_i = float(well_picks[w.name].split(' ')[0])
                        y_i = float(well_picks[w.name].split(' ')[1])
                        x_p = float(well_picks[key].split(' ')[0])
                        y_p = float(well_picks[key].split(' ')[1])
                        dist = round(sqrt((x_i-x_p)**2+(y_i-y_p)**2),1)                
                        if ROP_dict[key] < 0.95 and ROP_dict[key] != 0 and (well & MAIN != set()):
#                            mult_cut_1 = round(RP_Of_Tracer/ROP_dict[key],3)
#                            sum_mult_1 = mult_cut_1 + sum_mult_1
                            mult_tracer = RP_Of_Tracer*(1-m_t)/(0.9*m_t)+(m_t-0.1)/(0.9*m_t)
                            if RP_Of_Tracer < 0.1:
                                mult_tracer = 1
                            mult_tracer = mult_tracer*ROP_dict[key]
                        elif ROP_dict[key] > 1.05 and (well & MAIN != set()):
#                            mult_cut_2 = RP_Of_Tracer*ROP_dict[key]
#                            sum_mult_2 = mult_cut_2 + sum_mult_2   
                            mult_tracer = RP_Of_Tracer*(m_t-1)/0.9+(0.1*m_t+1)/0.9
                            if RP_Of_Tracer < 0.1:
                                mult_tracer = 1   
                            mult_tracer = mult_tracer*ROP_dict[key]
                        if RP_Of_Tracer  > 0.05 and (well & MAIN != set()):
                            k_mult_tracer = mult_tracer - 1
                            k_mult_dif_oil = dif_oil_prod(key)
                            k_mult_dif_oil_with_tracer = round(k_mult_dif_oil * k_mult_tracer,1)
                            avr_pres = check_pressure(w.name,key)
                            eval('prod_press_{}.append(avr_pres)'.format(w.name))
                            eval('mult_tracer_{}.append(mult_tracer)'.format(w.name))
                            eval('k_mult_tracer_{}.append(k_mult_tracer)'.format(w.name))
                            eval('k_mult_dif_oil_{}.append(k_mult_dif_oil_with_tracer)'.format(w.name))
#                            dif_oil_prod = dif_oil_prod(key)
                            ROP_tracer_press[w.name] = ROP_tracer_press[w.name]+'('+key+'_'+str(len(str(k_mult_dif_oil)))+':'+str(k_mult_dif_oil_with_tracer)+' '+str(ROP_dict[key])+' '+str(RP_Of_Tracer)+' '+str(avr_pres)+') '                         
#                            ROP_dict_summary[w.name] = ROP_dict_summary[w.name]+key+':'+str(ROP_dict[key])+' '
                            print(w.name,key,ROP_dict[key],RP_Of_Tracer,dist,avr_pres,sep='\t')
                        elif well & MAIN == set() and RP_Of_Tracer  > 0.05:
                            print(w.name,key,'БУФЕР',sep='\t')
                        sum_trac = sum_trac + RP_Of_Tracer
                        dict_well_tracer.close()
#                if abs(sum_mult_1-sum_mult_2) > 0.05:
                fun_arr_cut(w.name)
    
                tracer_inj.close()
            except FileNotFoundError:
                pass
            except KeyError:
                pass

print('/',file=ARR_CUT)
print(arr_cut_dict,file=arr_cut_dict_file)
ARR_CUT.close()
arr_cut_dict_file.close()
dict_well_picks.close()
dict_well_trac_A.close()
dict_well_perf.close()
#dict_res_pressure_file.close()

'''
СОЗДАНИЕ СЛОВОРЯ - (Отношение добычи воды по пропласткам)
'''
dict_well_WC_interval = open(get_project_folder()+'/skript/dict/dict_well_WC_interval.txt','w')                             #{'СКВАЖИНА': '0.444 0.556 0.0'}
well_WC_interval = dict()

MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}

for m in get_all_models():
    if float(FLPTH[m].max(dates='all').to_list()[0]) > 0:
        well = ''
        c_k_total = 0
        c_k_sum = dict()
        for k in MODEL_CELLS.keys():
            c_k_sum[k] = 0 
        for w in get_all_wells():
            for c in w.connections:
                c_k = cwpt[m,c].max(dates = 'all').to_list()[0]                                                                 #Накопленная добыча воды из ячейки
    #            water_by_interv(w.name)
                if str(c.well) != well and c_k_total != 0:     
                    well_WC_interval[well] = ''
                    if well != '':
                         for k in range(1,len(MODEL_CELLS)+1):
                             print(well,round(c_k_sum[str(k)]/c_k_total,3),sep='\t')
                             if well_WC_interval[well] == '':
                                 well_WC_interval[well] = str(round(c_k_sum[str(k)]/c_k_total,3))
                             else:
                                 well_WC_interval[well] = well_WC_interval[well] +' '+ str(round(c_k_sum[str(k)]/c_k_total,3))
                    c_k_total = 0
                    c_k_sum = dict()   
                    for k in MODEL_CELLS.keys():
                        c_k_sum[k] = 0          
                
                for key,val in MODEL_CELLS.items():
                    if int(val.split(',')[0]) <= int(c.k) <= int(val.split(',')[1]):
                        c_k_sum[key] = c_k_sum[key] + c_k
                        c_k_total = c_k_total + c_k
                        print(c.well,key,val,c.k,round(c_k_sum[key],1),round(c_k_total,1))
                well = str(c.well)
print(well_WC_interval,file=dict_well_WC_interval)
dict_well_WC_interval.close()       


'''
чтение данных из словаря (анализ обводненности) ARR_MULT_IP ARR_PERF ARR_OWC NNC
'''


from math import sqrt
#MODEL_OWC = {'1': '1494.0','2': '1486.5', '3': '1486.5'}
#MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}
#MODEL_ZONE = {'1','2','3'}
MAIN = {'100', '101', '10106', '10107', '11700', '11701', '11919', '11920', '11921', '11921D', '11979', '11980', '11981', '11982', '11983', '11984', '11985', '11986', '11987', '11988', '12042', '12043', '12044', '12045', '12233', '12234', '12235', '12236', '12237', '12238', '12239', '12240', '12241', '12242', '13401', '13402', '13403', '13404', '13405', '13406', '13407', '13408', '13409', '13410', '13411', '13412', '13413', '13414', '13415', '13416', '13417', '13418', '13419', '13420', '13421', '13422', '13423', '13424', '13425', '13426', '13427', '13427D', '13428', '13429', '13430', '13431', '13432', '13433', '13434', '13435', '13436', '13437', '13438', '13439', '13440', '13441', '13442', '13444', '13445', '13446', '13448', '13449', '13450', '13451', '13452', '13453', '13454', '13455', '13456', '13457', '13458', '13458D', '13459', '13460', '13461', '13462', '13463', '13464', '13465', '13466', '13467', '13468', '13469', '13470', '13471', '13472', '13473', '13474', '13475', '13476', '13477', '13478', '13479', '13480', '13481', '13483', '13484', '13485', '13486', '13487', '13488', '13489', '13490', '13491', '13492', '13493', '13494', '13495', '13496', '13497', '13498', '13499', '13501', '13503', '13504', '13506', '13507', '13508', '13509', '13510', '13511', '13512', '13513', '13514', '13515', '13516', '13518', '13519', '13520', '13521', '13522', '13523', '13524', '13525', '13526', '13527', '13528', '13529', '13530', '13531', '13532', '13533', '13534', '13535', '13536', '13537', '13538', '13539', '13540', '13541', '13542', '13543', '13544', '13545', '13546', '13547', '13548', '13549', '13550', '13551', '13552', '13553', '13554', '13555', '13556', '13557', '13558', '13559', '13560', '13561', '13563', '13564', '13565', '13566', '13567', '13568', '13569', '13570', '13572', '13573', '13574', '13575', '13576', '13577', '13578', '13579', '13580', '13581', '13582', '13583', '13584', '13585', '13586', '13588', '13589', '13590', '13591', '13592', '13593', '13594', '13595', '13596', '13597', '13598', '13599', '13600', '15113', '15113D', '15114', '16304', '16336', '16482', '16526', '16529', '16530', '16537', '16539', '16540', '16541', '16544', '16547', '17419', '17483', '21292', '21440', '21493', '21502', '21503', '21504', '21505', '21506', '21507', '21508', '21509', '21510', '21511', '21512', '21513', '21514', '21515', '21516', '21517', '21519', '21520', '21521', '21522', '21523', '21524', '21525', '21526', '21527', '21528', '21529', '21530', '21531', '21532', '21533', '21535', '21536', '21537', '21538', '21539', '21540', '21541', '21542', '21543', '21544', '21545', '21546', '21547', '21548', '21550', '21551', '21552', '21553', '21555', '21556', '21557', '21558', '21559', '21560', '21561', '21562', '21563', '21564', '21565', '21566', '21567', '21568', '21569', '21570', '21571', '21572', '21573', '21575', '21576', '21577', '21578', '21579', '21580', '21581', '21582', '21583', '21584', '21587', '21588', '21589', '21590', '21591', '21592', '21593', '21594', '21595', '21596', '21598', '21599', '21600', '21601', '21602', '21603', '21604', '21607', '21608', '21611', '21612', '21614', '21615', '21616', '21617', '21618', '21619', '21620', '21621', '21622', '21625', '21626', '21627', '21629', '21630', '21632', '21633', '21634', '21635', '21636', '21637', '21638', '21640', '21641', '21642', '21643', '21645', '21646', '21647', '21648', '21650', '21651', '21652', '21653', '21654', '21655', '21656', '21658', '21659', '21660', '21661', '21662', '21663', '21664', '21665', '21666', '21667', '21668', '21671', '21672', '21673', '21674', '21675', '21678', '21679', '21680', '21681', '21682', '21683', '21684', '21684A', '21685', '21686', '21687', '21688', '21689', '21691', '21692', '21694', '21696', '21697', '21698', '21699', '21700', '21701', '21702', '21703', '21704', '21705', '21706', '21707', '21708', '21710', '21711', '21712', '21713', '21714', '21715', '21716', '21717', '21718', '21719', '21720', '21721', '21724', '21725', '21726', '21727', '21731', '21732', '21733', '21734', '21735', '21736', '21738', '21740', '21741', '21742', '21743', '21744', '21745', '21746', '21747', '21748', '21750', '21751', '21753', '21755', '21757', '21758', '21759', '21760', '21761', '21762', '21763', '21764', '21765', '21766', '21767', '21768', '21769', '21771', '21772', '21773', '21774', '21775', '21776', '21777', '21778', '21779', '21780', '21781', '21782', '21783', '21784', '21785', '21786', '21787', '21789', '21790', '21791', '21793', '21794', '21796', '21798', '21799', '21800', '25283', '25284', '25285', '25286', '25287', '25288', '25289', '25290', '25293', '25294', '25297', '25298', '25299', '25300', '27303', '27305', '27310', '27315', '27385', '27395', '27481', '27483', '27484', '27487', '32801', '32804', '32805', '32806', '32810', '32813', '32814', '32816', '32817', '32818', '32819', '32820', '32821', '32826', '32827', '32830', '32835', '32836', '32842', '32843', '32844', '32845', '32846', '32854', '32863', '32866', '32868', '32869', '32874', '32875', '32876', '32877', '32878', '32881', '32882', '32883', '32884', '32885', '32886', '32887', '32888', '32889', '32890', '32892', '32893', '32894', '32895', '32896', '32898', '32907', '32910', '32914', '32916', '32917', '32918', '32919', '32920', '32921', '32922', '32923', '32924', '32925', '32929', '32930', '32931', '32940', '32941', '32943', '32947', '32948', '32950', '32954', '32955', '32956', '32957', '32958', '32959', '32960', '3498', '3515', '3516', '3517', '3556', '3557', '3558', '3597', '48', '48D', '49', '5042', '51', '527', '53', '530', '54', '570', '571', '5712', '5713', '5714', '5715', '5716', '5717', '5718', '5719', '5719D', '572', '5720', '5721', '5722', '5722A', '5723', '5724', '5725', '5725A', '5726', '5727', '5728', '5728A', '5729', '5730', '5731', '5731A', '5732', '5733', '5734', '5735', '5736', '5737', '5738', '5739', '5740', '5741', '5741D', '5742', '5743', '5744', '5745', '5746', '5747', '5748', '5749', '5750', '5751', '58', '5801', '5802', '5803', '5804', '5805', '5806', '5806D', '5807', '5807D', '5808', '5809', '5810', '5811', '5811D', '5812', '5813', '5814', '5815', '5815D', '5816', '5816D', '5817', '5818', '5819', '5820', '5821', '5822', '5823', '5824', '5825', '5826', '5827', '5827D', '5828', '5829', '5830', '5831', '5832', '5833', '5834', '5835', '5836', '5837', '5838', '5839', '5840', '5840D', '5841', '5842', '5843', '5844', '5845', '5846', '5847', '5848', '5849', '5850', '5851', '5852', '5853', '5854', '5855', '5856', '5857', '5858', '5859', '5860', '5861', '5862', '5863', '5864', '5864D', '5865', '5865D', '5866', '5867', '5868', '5869', '5870', '5871', '5872', '5873', '5873D', '5874', '5875', '5876', '5877', '5878', '5879', '5880', '5881', '5882', '5883', '5884', '5884D', '5885', '5886', '5887', '5888', '5890', '5891', '5892', '5893', '5894', '5895', '5896', '5897', '5897D', '5898', '5899', '5900', '5901', '5902', '5902D', '5903', '5904', '5905', '5906', '5906D', '5907', '5907D', '5908', '5909', '5909D', '5910', '5911', '5912', '5913', '5913A', '5914', '5915', '5916', '5917', '5918', '5919', '5920', '5921', '5922', '5923', '5924', '5925', '5926', '5927', '5927D', '5928', '5928D', '5929', '5929D', '5930', '5930D', '5931', '5932', '5933', '5934', '5935', '5936', '5937', '5938', '5939', '5940', '5940D', '5941', '5941D', '5942', '5943', '5944', '5945', '5946', '5947', '5947D', '5948', '5949', '5950', '5951', '5952', '5953', '5954', '5955', '5955D', '5956', '5956D', '5957', '5958', '5959', '5960', '5961', '5962', '5963', '5964', '5965', '5966', '5967', '5968', '5969', '5970', '5971', '5972', '5973', '5974', '5975', '5976', '5977', '5978', '5979', '5980', '5981', '5982', '5983', '5984', '5985', '5986', '5987', '5988', '5991', '5992', '5993', '5994', '5995', '5996', '5997', '5998', '5999', '651', '652', '653', '7400', '7401', '7402', '77D', '8000', '8001', '8002', '8002D', '8003', '8004', '8005', '8006', '8007', '8008', '8008D', '8009', '8010', '8011', '8012', '8013', '8014', '8015', '8016', '8017', '8018', '8019', '8020', '8021', '8021D', '8022', '8022D', '8023', '8024', '8025', '8026', '8027', '8028', '8029', '8030', '8031', '8032', '8033', '8034', '8035', '8036', '8037', '8038', '8039', '8040', '8041', '8042', '8043', '8044', '8045', '8046', '8047', '8048', '8049', '8050', '8051', '8052', '8053', '8053B', '8054', '8055', '8056', '8057', '8058', '8059', '8060', '8061', '8062', '8063', '8064', '8065', '8066', '8067', '8068', '8069', '8070', '8071', '8072', '8073', '8074', '8075', '8076', '8077', '8078', '8079', '8080', '8081', '8081D', '8082', '8083', '8084', '8085', '8086', '8087', '8088', '8089', '8090', '8091', '8092', '8093', '8094', '8094D', '8095', '8096', '8097', '8098', '8099', '8100', '8101', '8102', '8103', '8104', '8106', '8107', '8108', '8109', '8110', '8111', '8112A', '8113', '8114', '8115', '8116', '8117', '8118', '8119', '8120', '8121', '8122', '8123', '8124', '8125', '8127', '8128', '8129', '8131', '8132', '8133', '8134', '8135', '8136', '8137', '8138', '8139', '8140', '8141', '8141D', '8142', '8143', '8144', '8145', '8146', '8147', '8148A', '8149', '8150', '8151', '8152', '8153', '8154', '8155', '8156', '8157', '8158', '8159', '8160', '8161', '8162', '8162D', '8163', '8164', '8165', '8166', '8167', '8168', '8168D', '8169', '8170', '8171', '8172', '8173', '8174', '8175', '8176', '8177', '8178', '8179', '8180', '8181', '8182', '8183', '8184', '8185', '8186', '8187', '8188', '8189', '8190', '8191', '8192', '8193', '8194', '8195', '8196', '8197', '8198', '8198D', '8199', '8200', '84', '84D'}
NEGERMET = {'84', '8199', '8197', '8195', '8191', '8190', '8187', '8171', '8169', '8168', '8165', '8164', '8161', '8159', '8158', '8156', '8152', '8150', '8148A', '8147', '8144', '8137', '8136', '8133', '8124', '8123', '8122', '8116', '8112A', '8110', '8109', '8092', '8090', '8088', '8084', '8076', '8074', '8072', '8067', '8064', '8060', '8058', '8057', '8056', '8052', '8050', '8049', '8048', '8046', '8045', '8043', '8037', '8036', '8032', '8027', '8024', '8018', '8017', '8016', '8013', '8012', '8010', '8009', '8008', '8005', '77D', '6805', '675', '6712', '6601', '652', '651', '65', '5995', '5992', '5991', '5985', '5983', '5982', '5981', '5980', '5979', '5978', '5976', '5972', '5971', '5967', '5966', '5965', '5964', '5959', '5958', '5956D', '5956', '5954', '5952', '5951', '5950', '5949', '5946', '5943', '5939', '5936', '5929D', '5927', '5925', '5924', '5915', '5913A', '5910', '5906D', '5903', '5901', '5893', '5886', '5881', '5878', '5876', '5872', '5870', '5868', '5867', '5865D', '5865', '5864', '5863', '5862', '5858', '5857', '5853', '5851', '5850', '5846', '5845', '5844', '5843', '5840', '5838', '5836', '5832', '5830', '5825', '5823', '5821', '5820', '5818', '5816', '5815D', '5815', '5812', '5811', '5809', '5807D', '5805', '5804', '5758', '5757', '5752', '5751', '5749', '5745', '5743', '5739', '5737', '5736', '5734', '5733', '5731', '5729', '5728', '5726', '5725A', '5725', '5724', '5722', '572', '5719D', '5718', '5717', '5716', '5713', '5712', '5711', '5710', '571', '5709', '5708', '5694', '5693', '5692', '5691', '5687', '5433', '5432', '530', '51', '3597', '3517', '3515', '32898', '32881', '32878', '32520', '27395', '25288', '22126', '22125', '22123', '22112', '21913', '21856', '21848', '21814', '21811', '21794', '21781', '21778', '21774', '21767', '21765', '21751', '21726', '21716', '21705', '21680', '21675', '21656', '21652', '21648', '21646', '21645', '21636', '21635', '21617', '21593', '21592', '21590', '21575', '21566', '21560', '21555', '21553', '21542', '21529', '21527', '21523', '21519', '21514', '21440', '21439', '21433', '21429', '21427', '21424D', '21424', '21381', '21380', '21317', '21259', '21256', '21252', '21222', '21208', '21193', '21191', '17483', '17472', '17427', '17406', '16547', '16541', '15113', '14789', '14787', '14786', '14782', '14779', '14713', '14711', '14705', '13597', '13595', '13585', '13577', '13573', '13561', '13556', '13552', '13550', '13536', '13534', '13530', '13529', '13528', '13524', '13522', '13513', '13512', '13509', '13499', '13495', '13493', '13492', '13489', '13485', '13484', '13473', '13472', '13468', '13462', '13461', '13459', '13454', '13453', '13442', '13436', '13434', '13433', '13432', '13431', '13425', '13423', '13422', '13420', '13419', '13418', '13416', '13415', '13410', '13404', '13403', '13351', '13330', '12396', '12395', '12245', '12244', '12237', '11988', '11920', '11804D', '11756', '11303A', '11301', '11298', '10120', '10115'}

max_mult = 4
max_mult_perf = 2
max_OWC = 1
wells_number = 50 
min_oil_prod = 10000
OWC_1 = 1494.0
OWC_2 = 1486.5
OWC_3 = 1486.5
zone1 = set([i for i in range(1,16)])
zone2 = set([i for i in range(18,49)])
zone3 = set([i for i in range(51,180)])
dict_well_trac_A=open(get_project_folder()+'/skript/dict/dict_well_trac_A.txt','r')
dict_well_trac_RP=open(get_project_folder()+'/skript/dict/dict_well_trac_RP.txt','r')
dict_well_ROP = open(get_project_folder()+'/skript/dict/dict_well_ROP.txt','r')
dict_well_picks = open(get_project_folder()+'/skript/dict/dict_well_picks.txt','r')
dict_well_picks_reverse = open(get_project_folder()+'/skript/dict/dict_well_picks_reverse.txt','r')
dict_well_perf = open(get_project_folder()+'/skript/dict/dict_well_perf.txt','r')
arr_mult_file = open(get_project_folder()+'/skript/ARR_MULT_IP.txt','w')
OWC_file = open(get_project_folder()+'/skript/data/OWC.txt','r')
arr_OWC = open(get_project_folder()+'/skript/ARR_OWC.txt','w')
dict_well_WC_interval = open(get_project_folder()+'/skript/dict/dict_well_WC_interval.txt','r')
arr_perf = open(get_project_folder()+'/skript/ARR_PERF.txt','w')
arr_perf_dict_file = open(get_project_folder()+'/skript/dict/arr_perf_dict.txt','w')
arr_mult_ip_dict_file = open(get_project_folder()+'/skript/dict/arr_mult_ip_dict.txt','w')

well_trac_A = eval(dict_well_trac_A.read())
well_trac_RP = eval(dict_well_trac_RP.read())

well_ROP = eval(dict_well_ROP.read())
well_picks = eval(dict_well_picks.read())
well_picks_reverse = eval(dict_well_picks_reverse.read())
well_perf = eval(dict_well_perf.read())
well_WC_interval = eval(dict_well_WC_interval.read())
content = OWC_file.readlines()
content_matrix = [[content[i].split('\t')[j] for j in range(len(content[i].split('\t')))] for i in range(len(content))] 
OWC_dict = dict()
arr_perf_dict = dict()
arr_mult_ip_dict = dict()
#print(content_matrix[0][0],content_matrix[0][1],content_matrix[0][2],content_matrix[0][3],content_matrix[0][4],content_matrix[0][5],content_matrix[0][6])
for i in range(len(content)):
    OWC_dict[content_matrix[i][0]] = content_matrix[i][1]+'\t'+content_matrix[i][2]+'\t'+content_matrix[i][3]+'\t'+content_matrix[i][4]+'\t'+content_matrix[i][5]+'\t'+content_matrix[i][6]

#СОЗДАНИЕ СПИСКА НЕСАДАПТИРОВАННЫХ СКВАЖИН, ИМЕЮЩИХ ВЫСОКУЮ ДОБЫЧУ НЕФТИ
prod_adapt = dict()
prod_adapt_set = set()
for m in get_all_models():
    if float(FLPTH[m].max(dates='all').to_list()[0]) > 0:
        for w in get_all_wells():
            well_set = set()
            well_set.add(w.name)
            if well_set & MAIN != set():
                cum_oil_hist = round(wopth[m,w].max(dates = 'all').to_list()[0],1)
                cum_oil = round(wopt[m,w].max(dates = 'all').to_list()[0],1)
                if cum_oil_hist > 0:
                    adapt = abs(cum_oil_hist - cum_oil)*100/cum_oil_hist
                    if adapt > 20:
                        prod_adapt[cum_oil_hist] = w.name
                
sorted_dict = sorted(prod_adapt)
for i in sorted_dict[-1:-1*wells_number-1:-1]:
    prod_adapt_set.add(prod_adapt[i])

def get_key(value):
    for k, v in well_tracer.items():
        if v == value:
            return k

def arr_mult(w_i,w_p):
    well_inj_perf = set(well_perf[w_i])
    well_prod_perf = set(well_perf[w_p])
    zone_i = well_inj_perf & well_prod_perf
#    if float(well_WC[well_prod]) >= 1 and dolya_zak != 1:                          #ИСТОРИЯ ДОБЫЧИ ПО НЕФТИ БОЛЬШЕ РАСЧЕТА
#        mult = float(well_WC[w.name])/(1-dolya_zak)                                #НЕОБХОДИМО УВЕЛИЧИТЬ МУЛЬТ В ТОЧКЕ СКВАЖИНА ТРАССЕР
#    else:                                                                          #ИСТОРИЯ ДОБЫЧИ ПО НЕФТИ МЕНЬШЕ РАСЧЕТА
#        mult = float(well_WC[w.name])*(1-dolya_zak)                                #НЕОБХОДИМО УМЕНЬШИТЬ МУЛЬТ В ТОЧКЕ СКВАЖИНА ТРАССЕР
    if float(well_ROP[well_prod]) >= 1 and dolya_zak != 1:                          #ИСТОРИЯ ДОБЫЧИ ПО НЕФТИ БОЛЬШЕ РАСЧЕТА
        mult = float(well_ROP[w.name])**2/(1-dolya_zak)                             #НЕОБХОДИМО УВЕЛИЧИТЬ МУЛЬТ В ТОЧКЕ СКВАЖИНА ТРАССЕР
    else:                                                                           #ИСТОРИЯ ДОБЫЧИ ПО НЕФТИ МЕНЬШЕ РАСЧЕТА
        mult = float(well_ROP[w.name])**2*(1-dolya_zak)                             #НЕОБХОДИМО УМЕНЬШИТЬ МУЛЬТ В ТОЧКЕ СКВАЖИНА ТРАССЕР
    if str(x)+' '+str(y) == well_picks[well_prod]:       
        print('--ARR_MULT',mult,x,y,'/--',w.name,sep='\t')
        print('--ARR_MULT',mult,x,y,'/--',w.name,sep='\t',file=arr_mult_file)
        print('--ARR_MULT',mult,x,y,'/--',w.name,sep='\t',file=reason)
    else:
        if mult > max_mult:
            mult = max_mult
        if mult < 1/max_mult:
            mult = 1/max_mult
        if zone_i & {'1'} != set():
#            if float(well_WC[well_prod]) >= 1:
            if float(well_ROP[well_prod]) >= 1:
                mult_i = 1/sqrt(1.1-float(well_WC_interval[well_prod].split(' ')[0]))
            else:
                mult_i = sqrt(1.1-float(well_WC_interval[well_prod].split(' ')[0]))
#            print(mult_i)
            print('ARR_MULT',round(sqrt(mult*mult_i),3),x,x,y,y,min(zone1),max(zone1),'/-- '+str(w_p)+' - '+str(w_i)+' ДОЛЯ ВОДЫ '+str(round(dolya_zak,2)),sep='\t',file=arr_mult_file)
            print('ARR_MULT',round(sqrt(mult*mult_i),3),x,x,y,y,min(zone1),max(zone1),'/-- '+str(w_p)+' - '+str(w_i)+' ДОЛЯ ВОДЫ '+str(round(dolya_zak,2)),sep='\t',file=reason)
            print('ARR_MULT',round(sqrt(mult*mult_i),3),x,x,y,y,min(zone1),max(zone1),'/-- '+str(w_p)+' - '+str(w_i)+' ДОЛЯ ВОДЫ '+str(round(dolya_zak,2)),sep='\t')
            arr_mult_ip_dict[w.name+' '+str(min(zone1))+','+str(max(zone1))] = round(sqrt(mult*mult_i),3)
        if zone_i & {'2'} != set():
#            if float(well_WC[well_prod]) >= 1:
            if float(well_ROP[well_prod]) >= 1:
                mult_i = 1/sqrt(1.1-float(well_WC_interval[well_prod].split(' ')[1]))
            else:
                mult_i = sqrt(1.1-float(well_WC_interval[well_prod].split(' ')[1]))
#            print(mult_i)
            print('ARR_MULT',round(sqrt(mult*mult_i),3),x,x,y,y,min(zone2),max(zone2),'/-- '+str(w_p)+' - '+str(w_i)+' ДОЛЯ ВОДЫ '+str(round(dolya_zak,2)),sep='\t',file=arr_mult_file)
            print('ARR_MULT',round(sqrt(mult*mult_i),3),x,x,y,y,min(zone2),max(zone2),'/-- '+str(w_p)+' - '+str(w_i)+' ДОЛЯ ВОДЫ '+str(round(dolya_zak,2)),sep='\t',file=reason)
            print('ARR_MULT',round(sqrt(mult*mult_i),3),x,x,y,y,min(zone2),max(zone2),'/-- '+str(w_p)+' - '+str(w_i)+' ДОЛЯ ВОДЫ '+str(round(dolya_zak,2)),sep='\t')
            arr_mult_ip_dict[w.name+' '+str(min(zone2))+','+str(max(zone2))] = round(sqrt(mult*mult_i),3)
        if zone_i & {'3'} != set():
#            if float(well_WC[well_prod]) >= 1:
            if float(well_ROP[well_prod]) >= 1:
                mult_i = 1/sqrt(1.1-float(well_WC_interval[well_prod].split(' ')[2]))
            else:
                mult_i = sqrt(1.1-float(well_WC_interval[well_prod].split(' ')[2]))
#            print(mult_i)
            print('ARR_MULT',round(sqrt(mult*mult_i),3),x,x,y,y,min(zone3),max(zone3),'/-- '+str(w_p)+' - '+str(w_i)+' ДОЛЯ ВОДЫ '+str(round(dolya_zak,2)),sep='\t',file=arr_mult_file)
            print('ARR_MULT',round(sqrt(mult*mult_i),3),x,x,y,y,min(zone3),max(zone3),'/-- '+str(w_p)+' - '+str(w_i)+' ДОЛЯ ВОДЫ '+str(round(dolya_zak,2)),sep='\t',file=reason)
            print('ARR_MULT',round(sqrt(mult*mult_i),3),x,x,y,y,min(zone3),max(zone3),'/-- '+str(w_p)+' - '+str(w_i)+' ДОЛЯ ВОДЫ '+str(round(dolya_zak,2)),sep='\t')  
            arr_mult_ip_dict[w.name+' '+str(min(zone3))+','+str(max(zone3))] = round(sqrt(mult*mult_i),3)
            
            
def perf_mult(w_p):
    x_well = well_picks[str(w_p)].split(' ')[0]
    y_well = well_picks[str(w_p)].split(' ')[1]
    if len(well_perf[w_p]) >= 2:
#        arr_perf_mult = float(well_WC[w_p])
        arr_perf_mult = float(well_ROP[w_p])
        if arr_perf_mult > max_mult_perf:
            arr_perf_mult = max_mult_perf
        elif arr_perf_mult < 1/max_mult_perf:
            arr_perf_mult = 1/max_mult_perf
        if set(well_perf[w_p]) & {'1'} != set():
            WC1 = float(well_WC_interval[w_p].split(' ')[0])
        else:
            WC1 = 100
        if set(well_perf[w_p]) & {'2'} != set():
            WC2 = float(well_WC_interval[w_p].split(' ')[1])
        else:
            WC2 = 100
        if set(well_perf[w_p]) & {'3'} != set():
            WC3 = float(well_WC_interval[w_p].split(' ')[2])
        else:
            WC3 = 100
#        print(float(well_WC_interval[w_p].split(' ')[0]),float(well_WC_interval[w_p].split(' ')[1]),float(well_WC_interval[w_p].split(' ')[2]))
        max_zone = max(float(well_WC_interval[w_p].split(' ')[0]),float(well_WC_interval[w_p].split(' ')[1]),float(well_WC_interval[w_p].split(' ')[2]))
        min_zone = min(WC1,WC2,WC3)
#        print(max_zone,min_zone,WC1,WC2,WC3,well_WC_interval[w_p])
        if set(well_perf[w_p]) & {'1'} != set():
            if float(well_WC_interval[w_p].split(' ')[0]) == max_zone:
                print('ARR_PERF',arr_perf_mult,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(w_p)+' САМЫЙ ВЫСОКООБВОДНЕННЫЙ ПЛАСТ '+str(max_zone),sep='\t')
                print('ARR_PERF',arr_perf_mult,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(w_p)+' САМЫЙ ВЫСОКООБВОДНЕННЫЙ ПЛАСТ '+str(max_zone),sep='\t',file=arr_perf)
                print('ARR_PERF',arr_perf_mult,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(w_p)+' САМЫЙ ВЫСОКООБВОДНЕННЫЙ ПЛАСТ '+str(max_zone),sep='\t',file=reason)
                arr_perf_dict[w.name+' '+str(min(zone1))+','+str(max(zone1))] = arr_perf_mult
            if float(well_WC_interval[w_p].split(' ')[0]) == min_zone:
                print('ARR_PERF',round(1/arr_perf_mult,3),x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(w_p)+' САМЫЙ НИЗКООБВОДНЕННЫЙ ПЛАСТ '+str(min_zone),sep='\t')
                print('ARR_PERF',round(1/arr_perf_mult,3),x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(w_p)+' САМЫЙ НИЗКООБВОДНЕННЫЙ ПЛАСТ '+str(min_zone),sep='\t',file=arr_perf)
                print('ARR_PERF',round(1/arr_perf_mult,3),x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(w_p)+' САМЫЙ НИЗКООБВОДНЕННЫЙ ПЛАСТ '+str(min_zone),sep='\t',file=reason)
                arr_perf_dict[w.name+' '+str(min(zone1))+','+str(max(zone1))] = round(1/arr_perf_mult,3)
        if set(well_perf[well_prod]) & {'2'} != set():
            if float(well_WC_interval[w_p].split(' ')[1]) == max_zone:
                print('ARR_PERF',arr_perf_mult,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(w_p)+' САМЫЙ ВЫСОКООБВОДНЕННЫЙ ПЛАСТ '+str(max_zone),sep='\t') 
                print('ARR_PERF',arr_perf_mult,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(w_p)+' САМЫЙ ВЫСОКООБВОДНЕННЫЙ ПЛАСТ '+str(max_zone),sep='\t',file=arr_perf)
                print('ARR_PERF',arr_perf_mult,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(w_p)+' САМЫЙ ВЫСОКООБВОДНЕННЫЙ ПЛАСТ '+str(max_zone),sep='\t',file=reason)
                arr_perf_dict[w.name+' '+str(min(zone2))+','+str(max(zone2))] = arr_perf_mult
            if float(well_WC_interval[w_p].split(' ')[1]) == min_zone:
                print('ARR_PERF',round(1/arr_perf_mult,3),x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(w_p)+' САМЫЙ НИЗКООБВОДНЕННЫЙ ПЛАСТ '+str(min_zone),sep='\t')   
                print('ARR_PERF',round(1/arr_perf_mult,3),x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(w_p)+' САМЫЙ НИЗКООБВОДНЕННЫЙ ПЛАСТ '+str(min_zone),sep='\t',file=arr_perf) 
                print('ARR_PERF',round(1/arr_perf_mult,3),x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(w_p)+' САМЫЙ НИЗКООБВОДНЕННЫЙ ПЛАСТ '+str(min_zone),sep='\t',file=reason) 
                arr_perf_dict[w.name+' '+str(min(zone2))+','+str(max(zone2))] = round(1/arr_perf_mult,3)
        if set(well_perf[w_p]) & {'3'} != set():
            if float(well_WC_interval[w_p].split(' ')[2]) == max_zone:
                print('ARR_PERF',arr_perf_mult,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(w_p)+' САМЫЙ ВЫСОКООБВОДНЕННЫЙ ПЛАСТ '+str(max_zone),sep='\t')    
                print('ARR_PERF',arr_perf_mult,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(w_p)+' САМЫЙ ВЫСОКООБВОДНЕННЫЙ ПЛАСТ '+str(max_zone),sep='\t',file=arr_perf)   
                print('ARR_PERF',arr_perf_mult,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(w_p)+' САМЫЙ ВЫСОКООБВОДНЕННЫЙ ПЛАСТ '+str(max_zone),sep='\t',file=reason)   
                arr_perf_dict[w.name+' '+str(min(zone3))+','+str(max(zone3))] = arr_perf_mult
            if float(well_WC_interval[w_p].split(' ')[2]) == min_zone:
                print('ARR_PERF',round(1/arr_perf_mult,3),x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(w_p)+' САМЫЙ НИЗКООБВОДНЕННЫЙ ПЛАСТ '+str(min_zone),sep='\t')
                print('ARR_PERF',round(1/arr_perf_mult,3),x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(w_p)+' САМЫЙ НИЗКООБВОДНЕННЫЙ ПЛАСТ '+str(min_zone),sep='\t',file=arr_perf)
                print('ARR_PERF',round(1/arr_perf_mult,3),x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(w_p)+' САМЫЙ НИЗКООБВОДНЕННЫЙ ПЛАСТ '+str(min_zone),sep='\t',file=reason)
                arr_perf_dict[w.name+' '+str(min(zone3))+','+str(max(zone3))] = round(1/arr_perf_mult,3)
        
def OWC(w_p):
    well_prod_perf = set(well_perf[w_p])
    x_well = int(well_picks[str(well_prod)].split(' ')[0])
    y_well = int(well_picks[str(well_prod)].split(' ')[1])
    k_OWC = 1-float(well_trac_RP[well_prod])
    
    if well_prod_perf & {'1'} != set():
        try:
            OWC_top = round(float(OWC_dict[str(w.name)].split('\t')[0]),1)
        except:
            OWC_top = OWC_dict[str(w.name)].split('\t')[0]
        try:
            OWC_bot = round(float(OWC_dict[str(w.name)].split('\t')[1]),1)
        except:
            OWC_bot = OWC_dict[str(w.name)].split('\t')[1]
#        if float(well_WC[w.name]) < 1:     
        if float(well_ROP[w.name]) < 1:                                                    #Опускаем ВНК
            if OWC_bot != '-' and OWC_top != '-':
                OWC_value = round((OWC_bot-OWC_top)*k_OWC + (OWC_bot+OWC_top)/2,1)
            elif OWC_bot != '-' and OWC_top == '-' and OWC_1 < OWC_bot:
                OWC_value = round(min(OWC_1 + (OWC_bot - OWC_1)*k_OWC,OWC_bot),1)
            elif OWC_bot != '-' and OWC_top == '-' and OWC_1 >= OWC_bot:
                OWC_value = 'skip'
            elif OWC_bot == '-' and OWC_top != '-':
                OWC_value = round(min(OWC_1,OWC_top)+max_OWC*k_OWC,1)
            else:
                OWC_value = '-'
            if OWC_value == '-' or OWC_value == 'skip':
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_1)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t')
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_1)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=arr_OWC)       
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_1)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=reason)  
            else:
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_1)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t')
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_1)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=arr_OWC)
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_1)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=reason)
#        elif float(well_WC[w.name]) > 1:     
        elif float(well_ROP[w.name]) > 1:                                                   #Поднимаем ВНК
            if OWC_bot != '-' and OWC_top != '-':
                OWC_value = round(-(OWC_bot-OWC_top)*k_OWC + (OWC_bot+OWC_top)/2,1)
            elif OWC_bot != '-' and OWC_top == '-':
                OWC_value = round(max(OWC_1,OWC_bot)-max_OWC*k_OWC,1)
            elif OWC_bot == '-' and OWC_top != '-' and OWC_1 > OWC_top:
                OWC_value = round(max(OWC_1 - (-OWC_top + OWC_1)*k_OWC,OWC_top),1)  
            elif OWC_bot == '-' and OWC_top != '-' and OWC_1 <= OWC_top:
                OWC_value = 'skip'
            else:
                OWC_value = '-'
            if OWC_value == '-' or OWC_value == 'skip':
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_1)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t')
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_1)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=arr_OWC)       
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_1)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=reason) 
            else:
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_1)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t')
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_1)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=arr_OWC)  
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_1)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=reason)
        else:
            pass 
            
    if well_prod_perf & {'2'} != set():
        try:
            OWC_top = round(float(OWC_dict[str(w.name)].split('\t')[2]),1)
        except:
            OWC_top = OWC_dict[str(w.name)].split('\t')[2]
        try:
            OWC_bot = round(float(OWC_dict[str(w.name)].split('\t')[3]),1)
        except:
            OWC_bot = OWC_dict[str(w.name)].split('\t')[3]
#        if float(well_WC[w.name]) < 1:     
        if float(well_ROP[w.name]) < 1:                                                    #Опускаем ВНК
            if OWC_bot != '-' and OWC_top != '-':
                OWC_value = round((OWC_bot-OWC_top)*k_OWC + (OWC_bot+OWC_top)/2,1)
            elif OWC_bot != '-' and OWC_top == '-' and OWC_2 < OWC_bot:
                OWC_value = round(min(OWC_2 + (OWC_bot - OWC_2)*k_OWC,OWC_bot),1)
            elif OWC_bot != '-' and OWC_top == '-' and OWC_2 >= OWC_bot:
                OWC_value = 'skip'
            elif OWC_bot == '-' and OWC_top != '-':
                OWC_value = round(min(OWC_2,OWC_top)+max_OWC*k_OWC,1)
            else:
                OWC_value = '-'
            if OWC_value == '-' or OWC_value == 'skip':
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_2)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t')
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_2)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=arr_OWC)
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_2)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=reason)
            else:
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_2)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t')
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_2)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=arr_OWC)
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_2)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=reason)
#        elif float(well_WC[w.name]) > 1:     
        elif float(well_ROP[w.name]) > 1:                                               #Поднимаем ВНК
            if OWC_bot != '-' and OWC_top != '-':
                OWC_value = round(-(OWC_bot-OWC_top)*k_OWC + (OWC_bot+OWC_top)/2,1)
            elif OWC_bot != '-' and OWC_top == '-':
                OWC_value = round(max(OWC_2,OWC_bot)-max_OWC*k_OWC,1)
            elif OWC_bot == '-' and OWC_top != '-' and OWC_2 > OWC_top:
                OWC_value = round(max(OWC_2 - (-OWC_top + OWC_2)*k_OWC,OWC_top),1)   
            elif OWC_bot == '-' and OWC_top != '-' and OWC_2 <= OWC_top:
                OWC_value = 'skip'
            else:
                OWC_value = '-'
            if OWC_value == '-' or OWC_value == 'skip':
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_2)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t')
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_2)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=arr_OWC)  
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_2)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=reason)
            else:
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_2)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t')
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_2)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=arr_OWC)     
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone2),max(zone2),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_2)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=reason)  
        else:
            pass 

    if well_prod_perf & {'3'} != set():
        try:
            OWC_top = round(float(OWC_dict[str(w.name)].split('\t')[4]),1)
        except:
            OWC_top = OWC_dict[str(w.name)].split('\t')[4]
        try:
            OWC_bot = round(float(OWC_dict[str(w.name)].split('\t')[5]),1)
        except:
            OWC_bot = OWC_dict[str(w.name)].split('\t')[5]
#        if float(well_WC[w.name]) < 1:                               
        if float(well_ROP[w.name]) < 1:                                #Опускаем ВНК
            if OWC_bot != '-\n' and OWC_top != '-':
                OWC_value = round((OWC_bot-OWC_top)*k_OWC + (OWC_bot+OWC_top)/2,1)
            elif OWC_bot != '-\n' and OWC_top == '-' and OWC_3 < OWC_bot:
                OWC_value = round(min(OWC_3 + (OWC_bot - OWC_3)*k_OWC,OWC_bot),1)
            elif OWC_bot != '-\n' and OWC_top == '-' and OWC_3 >= OWC_bot:
                OWC_value = 'skip'
            elif OWC_bot == '-\n' and OWC_top != '-':
                OWC_value = round(min(OWC_3,OWC_top)+max_OWC*k_OWC,1)
            else:
                OWC_value = '-'
            if OWC_value == '-' or OWC_value == 'skip':
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_3)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t')
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_3)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=arr_OWC)
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_3)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=reason)
            else:
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_3)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t')
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_3)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=arr_OWC)
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(well_prod)+' ОПУСКАЕМ ВНК '+str(OWC_3)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=reason)
#        elif float(well_WC[w.name]) > 1:                   
        elif float(well_ROP[w.name]) > 1:                                               #Поднимаем ВНК
            if OWC_bot != '-\n' and OWC_top != '-':
                OWC_value = round(-(OWC_bot-OWC_top)*k_OWC + (OWC_bot+OWC_top)/2,1)
            elif OWC_bot != '-\n' and OWC_top == '-':
                OWC_value = round(max(OWC_3,OWC_bot)-max_OWC*k_OWC,2)
            elif OWC_bot == '-\n' and OWC_top != '-' and OWC_3 > OWC_top:
                OWC_value = round(max(OWC_3 - (-OWC_top + OWC_3)*k_OWC,OWC_top),1)  
            elif OWC_bot == '-\n' and OWC_top != '-' and OWC_3 <= OWC_top:
                OWC_value = 'skip'
            else:
                OWC_value = '-'
            if OWC_value == '-' or OWC_value == 'skip':
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_3)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t')
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_3)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=arr_OWC)    
                print('--ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_3)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=reason)  
            else:
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_3)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t')
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_3)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=arr_OWC)     
                print('ARR_OWC',OWC_value,x_well,x_well,y_well,y_well,min(zone3),max(zone3),'/-- '+str(well_prod)+' ПОДНИМЕМ ВНК '+str(OWC_3)+' ПН '+str(OWC_top)+' КВ '+str(OWC_bot),sep='\t',file=reason) 
        else:
            pass 
  
#    print('ARR_OWC',depth,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/--',w.name,sep='\t',file=arr_OWC)     
#    print('ARR_OWC',depth,x_well,x_well,y_well,y_well,min(zone1),max(zone1),'/--',w.name,sep='\t')   

print('EQUALS\n',file=arr_mult_file)
print('EQUALS\n',file=arr_perf)
print('EQUALS\n',file=arr_OWC)

for m in get_all_models():
    if float(FLPTH[m].max(dates='all').to_list()[0]) > 0:
        for w in get_all_wells():
            well_prod = w.name
            well_set = set()
            well_set.add(well_prod)
#            if prod_adapt_set & well_set != set():  #СРАВНЕНИЕ СО СПИСКОМ СКВАЖИН КОТОРЫЕ ИМЕЮТ НАИБОЛЬШУЮ ДОБЫЧУ, НО НЕ САДАПТИРОВАНИЫ
            if (WOPTH[m,w].max(dates='all').to_list()[0]) > min_oil_prod:
    #TRACER
    #        try:
                if float(well_ROP[well_prod]) > 1:
                    recomand = 'Увеличить_обводненность'
                elif float(well_ROP[well_prod]) < 1:
                    recomand = 'Уменьшить_обводненность'
                else:
                    recomand = ''
                reason = open(get_project_folder()+'/skript/reason/'+well_prod+'.txt','w')
                print('\n'+str(well_prod))
                print('РАБОТА НА ПЛАСТЫ: ',well_perf[well_prod],sep='\t')
                print('РАСПРЕДЕЛЕНИЕ ДОБЫЧИ ВОДЫ ПО ПЛАСТАМ: ',well_WC_interval[well_prod],sep='\t')
                print('ДОБЫЧА_ТРАССЕРА_ОТ_НАГНЕТАТЕЛЬНЫХ_СКВАЖИН: ',well_trac_RP[well_prod],sep='\t')
                print('ОТНОШЕНИЕ_НАКОПЛЕННОЙ_ДОБЫЧИ_НЕФТИ_РАСЧЕТ/ИСТОРИЯ: ',well_ROP[well_prod],recomand,sep='\t')
    
                print('РАБОТА НА ПЛАСТЫ: ',well_perf[well_prod],sep='\t',file=reason)
                print('РАСПРЕДЕЛЕНИЕ ДОБЫЧИ ВОДЫ ПО ПЛАСТАМ: ',well_WC_interval[well_prod],sep='\t',file=reason)
                print('ДОБЫЧА_ТРАССЕРА_ОТ_НАГНЕТАТЕЛЬНЫХ_СКВАЖИН: ',well_trac_RP[well_prod],sep='\t',file=reason)
                print('ОТНОШЕНИЕ_НАКОПЛЕННОЙ_ДОБЫЧИ_НЕФТИ_РАСЧЕТ/ИСТОРИЯ: ',well_ROP[well_prod],recomand,sep='\t',file=reason)
                cum_oil_hist = round(wopth[m,w].max(dates = 'all').to_list()[0],1)
                cum_oil = round(wopt[m,w].max(dates = 'all').to_list()[0],1)
                if cum_oil_hist > 0:
                    adapt = abs(cum_oil_hist - cum_oil)*100/cum_oil_hist
                if adapt < 10:
                    print('СКВАЖИНА САДАПТИРОВАНА - АДАПТАЦИЯ НЕ НУЖНА',str(round(adapt,1))+' %',sep='\t')
                    print('СКВАЖИНА САДАПТИРОВАНА - АДАПТАЦИЯ НЕ НУЖНА',str(round(adapt,1))+' %',sep='\t',file=reason)
                    continue
                else:
                    print('СТЕПЕНЬ АДАПТАЦИИ СКВАЖИНЫ: ',str(round(adapt,1))+' %',sep='\t')
                    print('СТЕПЕНЬ АДАПТАЦИИ СКВАЖИНЫ: ',str(round(adapt,1))+' %',sep='\t',file=reason)
                if NEGERMET & well_set != set():
                    print('НА_СКВАЖИНЕ_БЫЛИ_ОБНАРУЖЕНЫ_НАРУШЕНИЯ_ОК/ЗАКОЛОННЫЕ_ПЕРЕТОКИ')
                    if float(well_ROP[well_prod]) > 1:
                        print('NNC',well_picks[well_prod].split(' ')[0],well_picks[well_prod].split(' ')[1],'k1',well_picks[well_prod].split(' ')[0],well_picks[well_prod].split(' ')[1],'k2',sep='\t')
                if float(well_ROP[w.name]) > 0:
                    dict_well_tracer = open(get_project_folder()+'/skript/tracer_prod/'+str(w.name)+'.txt','r')
                    well_tracer = eval(dict_well_tracer.read())
                    
                    for i in well_tracer.values():
                        dolya_zak = float(i)/sum(list(well_tracer.values()))*float(well_trac_RP[w.name])
                        if dolya_zak > 0.1:
                            well_inj = get_key(i)
                            #print(well_inj,round(dolya_zak,2))
                    
    #                        well_inj = get_key(max(well_tracer.values()))[1:]
    
    
                            x = round((float(well_picks[str(well_inj)].split(' ')[0])+float(well_picks[str(well_prod)].split(' ')[0]))/2)
                            y = round((float(well_picks[str(well_inj)].split(' ')[1])+float(well_picks[str(well_prod)].split(' ')[1]))/2)                         
                            
                            try: 
                                while well_picks_reverse[str(x)+' '+str(y)] != 0:
                                    if str(x)+' '+str(y) == well_picks[well_prod]:
                                        break
    #                                print('!!!!!!!!!!!!!!!!!!')
                                    x = round((x + float(well_picks[str(well_prod)].split(' ')[0]))/2)
                                    y = round((y + float(well_picks[str(well_prod)].split(' ')[1]))/2)
                            except:
                                pass
    
                            #print(well_inj,set(well_perf[well_inj]),well_prod,set(well_perf[well_prod]))
                            arr_mult(well_inj,well_prod)       
                            dict_well_tracer.close()
    
                perf_mult(well_prod)
    
                if float(well_ROP[w.name]) > 0:
                    OWC(well_prod)    
                reason.close()
    #        except KeyError:
    #            continue

print('/',file=arr_mult_file)
print('/',file=arr_perf)
print('/',file=arr_OWC)        
print(arr_perf_dict,file=arr_perf_dict_file)
print(arr_mult_ip_dict,file=arr_mult_ip_dict_file)
dict_well_trac_A.close()
dict_well_trac_RP.close()
dict_well_ROP.close()
dict_well_perf.close()
arr_mult_file.close()
OWC_file.close()
arr_OWC.close()
dict_well_WC_interval.close()
arr_perf.close()
arr_perf_dict_file.close()
arr_mult_ip_dict_file.close()
#OWC_interval.close()

'''
ИЗМЕНЕНИЕ ГЛУБИНЫ ВНК
'''
import re
OWC_file = open(get_project_folder()+'/skript/data/OWC.txt','r')
dict_well_trac_A_file = open(get_project_folder()+'/skript/dict/dict_well_trac_A.txt','r') 
dict_well_trac_A = eval(dict_well_trac_A_file.read())

MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}
dict_well_ROP_file = dict()
for k,v in MODEL_CELLS.items():
    dict_well_ROP_file[k] = open(get_project_folder()+'/skript/dict/dict_well_ROP_zone_'+k+'.txt','r')  
    file = eval(dict_well_ROP_file[k].read())
    exec('dict_well_ROP_{} = {}'.format(k,file))
#    print(eval('dict_well_ROP_{}'.format(k)))
    exec('OWC_dict_{} = dict()'.format(k))
    
content = OWC_file.readlines()
for l in content:
    s = l.split('\t')
    for k,v in MODEL_CELLS.items():
        try:
            exec("OWC_dict_{}[s[0]] = s[{}] +'\t'+ s[{}].strip()".format(k,int(k)*2-1,int(k)*2))
        except IndexError:
            print('IndexError')
for m in get_all_models():
    for w in get_all_wells():
        if wwpt[m,w].max(dates='all').to_list()[0] != 0:
            RWP_A = round(dict_well_trac_A[w.name]/wwpt[m,w].max(dates='all').to_list()[0],2)
        else:
            RWP_A = 'ZeroDivisionError'
        for k,v in MODEL_CELLS.items():
            value = eval('dict_well_ROP_{}'.format(k))
            try:
                if value[w.name] <= 0.1:
                    owc_value = eval('OWC_dict_{}'.format(k))
                    print(w.name,k,value[w.name],RWP_A,owc_value[w.name],sep='\t')
            except KeyError:
                pass


---------------------------------------------------------------------------------------------------------------------------------------------
ОПРЕДЕЛЕНИЕ ВЛЯНИЯ МУЛЬТИПЛИКАТОРОВ
---------------------------------------------------------------------------------------------------------------------------------------------
'''
ОЦЕНКА РАССЧЕТА (+ АДАПТАЦИЯ УЛУЧШЕЛАСЬ, - АДАПТАЦИЯ УХУЧШЕЛАСЬ)
ЕСЛИ ОТКРЫВАЕМ ИСХОДНУЮ МОДЕЛЬ
'''
count = 0
hist_oil = dict()
hist_liq = dict()
calc_oil = dict()
calc_liq = dict()
analysis = dict()
for m in get_all_models():
    if fopth[m].max(dates='all') > 0:
        for w in get_all_wells():
            hist_oil[w.name] = float(wopth[m,w].max(dates='all').to_list()[0])
            calc_oil[w.name] = float(wopt[m,w].max(dates='all').to_list()[0])
#            print(w.name,float(wopth[m,w].max(dates='all').to_list()[0]),hist_oil[w.name],float(wopt[m,w].max(dates='all').to_list()[0]),calc_oil[w.name])
    else:
        dict_analysis = open(get_project_folder()+'/skript/analysis/dict_analysis_'+str(count)+'.txt','w')
        for w in get_all_wells():
            if wopt[m,w].max(dates='all') > 0 and hist_oil[w.name] > 1:
                calc_oil_i = float(wopt[m,w].max(dates='all').to_list()[0])
                d1 = abs(calc_oil[w.name] - hist_oil[w.name])
                d2 = abs(calc_oil_i - hist_oil[w.name])
                analysis[w.name] = round((d1-d2)*100/hist_oil[w.name],1)  
                print(w.name,analysis[w.name],sep='\t') 
                
print(analysis,file=dict_analysis)
dict_analysis.close()
'''
ОЦЕНКА РАССЧЕТА (+ АДАПТАЦИЯ УЛУЧШЕЛАСЬ, - АДАПТАЦИЯ УХУЧШЕЛАСЬ)
ЕСЛИ ОТКРЫВАЕМ НОВУЮ РАССЧИТАННУЮ МОДЕЛЬ
'''
count_h = diff_h = count_c = diff_c = count_g_h = diff_g_h = count_g_c = diff_g_c = 0
hist_oil = dict()
hist_liq = dict()
calc_oil = dict()
calc_liq = dict()
analysis = dict()
for m in get_all_models():
    if fopth[m].max(dates='all') > 0:
        for w in get_all_wells():
            hist_oil[w.name] = float(wopth[m,w].max(dates='all').to_list()[0])
            calc_oil[w.name] = float(wopt[m,w].max(dates='all').to_list()[0])
            if float(wopth[m,w].max(dates='all').to_list()[0]) > 0:
                diff_h = abs(float(wopth[m,w].max(dates='all').to_list()[0])- float(wopt[m,w].max(dates='all').to_list()[0])) + diff_h
                count_h = count_h + 1
                
        for g in get_all_groups():
            if str(g.name) == 'MAIN':
                for w in g.wells: 
                    if float(wopth[m,w].max(dates='all').to_list()[0]) > 0:
                        diff_g_h = abs(float(wopth[m,w].max(dates='all').to_list()[0])-float(wopt[m,w].max(dates='all').to_list()[0])) + diff_g_h
                        count_g_h = count_g_h + 1
    else:
        dict_analysis = open(get_project_folder()+'/skript/analysis/dict_analysis.txt','w')
        for w in get_all_wells():
            if hist_oil[w.name] > 0:
                calc_oil_i = float(wopt[m,w].max(dates='all').to_list()[0])
                d1 = abs(calc_oil[w.name] - hist_oil[w.name])
                d2 = abs(calc_oil_i - hist_oil[w.name])
                analysis[w.name] = round((d2-d1)*100/hist_oil[w.name],1)  
                print(w.name,analysis[w.name],sep='\t') 
                
                diff_c = abs(hist_oil[w.name]-float(wopt[m,w].max(dates='all').to_list()[0])) + diff_c
                count_c = count_c + 1
                
        for g in get_all_groups():
            if str(g.name) == 'MAIN':
                for w in g.wells: 
                    if hist_oil[w.name] > 0:
                        diff_g_c = abs(hist_oil[w.name]-float(wopt[m,w].max(dates='all').to_list()[0])) + diff_g_c
                        count_g_c = count_g_c + 1
                
print('\n')
print('MAIN_cur:','{} тыс.т /{} скв = {} тыс.т/скв'.format(round(diff_g_h/1000,1),count_g_h,round(diff_g_h/count_g_h/1000,1)),sep='\t')
print('FIELD_cur:','{} тыс.т /{} скв = {} тыс.т/скв'.format(round(diff_h/1000,1),count_h,round(diff_h/count_h/1000,1)),sep='\t')
print('MAIN_past:','{} тыс.т /{} скв = {} тыс.т/скв'.format(round(diff_g_c/1000,1),count_g_c,round(diff_g_c/count_g_c/1000,1)),sep='\t')
print('FIELD_past:','{} тыс.т /{} скв = {} тыс.т/скв'.format(round(diff_c/1000,1),count_c,round(diff_c/count_c/1000,1)),sep='\t')
print('\n')
print('FIELD:',str(round(diff_c/count_c/1000-diff_h/count_h/1000,3))+' тыс.т./скв',sep='\t')
print('MAIN:',str(round(diff_g_c/count_g_c/1000-diff_g_h/count_g_h/1000,3))+' тыс.т./скв',sep='\t')
print(analysis,file=dict_analysis)
dict_analysis.close()
'''
ОСТАВЛЯЕМ ИЗМЕНЕНИЯ, КОТОРЫЕ ПОВЛИЯЛИ НА СКВАЖИНУ ПОЛОЖИТЕЛЬНО
ARR_PERF
'''
upgrade = 5     #ПРОЦЕНТ УЛУЧШЕНИЯ (ЕСЛИ МЕНЬШЕ ТО НЕ ВКЛЮЧАЕМ В СПИСОК)
dict_analysis = open(get_project_folder()+'/skript/analysis/dict_analysis.txt','r')
arr_perf_dict_file = open(get_project_folder()+'/skript/dict/arr_perf_dict.txt','r')
dict_well_picks = open(get_project_folder()+'/skript/dict/dict_well_picks.txt','r')
arr_perf_new = open(get_project_folder()+'/skript/analysis/ARR_PERF.txt','w')
#arr_perf_dict_file_new = open(get_project_folder()+'/skript/analysis/arr_perf_dict.txt','w')

analysis = eval(dict_analysis.read())
arr_perf_dict = eval(arr_perf_dict_file.read())
well_picks = eval(dict_well_picks.read())
#arr_perf_dict_new = dict()
MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}

print('EQUALS\n',file=arr_perf_new)
for k_a,v_a in analysis.items():
    for k_p,v_p in arr_perf_dict.items():
        if v_a > upgrade and k_a == k_p.split(' ')[0]:
            print('ARR_PERF',v_p,well_picks[k_a].split(' ')[0],well_picks[k_a].split(' ')[0],well_picks[k_a].split(' ')[1],well_picks[k_a].split(' ')[1],(k_p.split(' ')[1]).split(',')[0],(k_p.split(' ')[1]).split(',')[1],'/-- %s УЛУЧШЕНИЕ АДАПТАЦИИ + %.1f'%(k_a,v_a),sep='\t')
            print('ARR_PERF',v_p,well_picks[k_a].split(' ')[0],well_picks[k_a].split(' ')[0],well_picks[k_a].split(' ')[1],well_picks[k_a].split(' ')[1],(k_p.split(' ')[1]).split(',')[0],(k_p.split(' ')[1]).split(',')[1],'/-- %s УЛУЧШЕНИЕ АДАПТАЦИИ + %.1f'%(k_a,v_a),sep='\t',file=arr_perf_new)
#            arr_perf_dict_new[k_a] = v_p
print('/',file=arr_perf_new)
#print(arr_perf_dict,file=arr_perf_dict_file_new)
dict_analysis.close()
arr_perf_dict_file.close()
arr_perf_dict_file_new.close()
dict_well_picks.close()
arr_perf_new.close()
'''
ОСТАВЛЯЕМ ИЗМЕНЕНИЯ, КОТОРЫЕ ПОВЛИЯЛИ НА СКВАЖИНУ ПОЛОЖИТЕЛЬНО
ARR_MULT_IP / ARR_PERF
'''
name = 'ARR_PERF'
mult_name = 'ARR_PERF'
#name = 'ARR_MULT_IP'
#mult_name = 'ARR_MULT'

MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}
upgrade = 5     #ПРОЦЕНТ УЛУЧШЕНИЯ (ЕСЛИ МЕНЬШЕ ТО НЕ ВКЛЮЧАЕМ В СПИСОК)

dict_analysis = open(get_project_folder()+'/skript/analysis/dict_analysis.txt','r')
dict_well_perf = open(get_project_folder()+'/skript/dict/dict_well_perf.txt','r')
arr_old = open(get_project_folder()+'/skript/analysis/'+str(name)+'_old.txt','r')
arr_new = open(get_project_folder()+'/skript/analysis/'+str(name)+'_new.txt','w')
analysis = eval(dict_analysis.read())
well_perf = eval(dict_well_perf.read())

content = arr_old.readlines()
content_matrix = [[content[i].split('\t')[j] for j in range(len(content[i].split('\t')))] for i in range(len(content))] 

MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}

print('EQUALS',file=arr_new)
for n,j in enumerate(content):
    if len(content_matrix[n]) >= 8:
        well = content_matrix[n][8].split(' ')[1]
        if analysis[well] >  upgrade:
            mult = content_matrix[n][1]
            x = content_matrix[n][2]
            y = content_matrix[n][4]
            z1 = content_matrix[n][6]
            z2 =content_matrix[n][7]
            print(mult_name,mult,x,x,y,y,z1,z2,'/-- %s УЛУЧШЕНИЕ АДАПТАЦИИ + %.1f'%(well,analysis[well]),sep='\t')
            print(mult_name,mult,x,x,y,y,z1,z2,'/-- %s УЛУЧШЕНИЕ АДАПТАЦИИ + %.1f'%(well,analysis[well]),sep='\t',file=arr_new)
            
print('/',file=arr_new)
dict_analysis.close()
dict_well_perf.close()
arr_old.close()
arr_new.close()

---------------------------------------------------------------------------------------------------------------------------------------------
СЦЕПЛЕНИЕ 2 МУЛЬТИПЛИКАТОРОВ
---------------------------------------------------------------------------------------------------------------------------------------------
name = 'ARR_MULT_IP'
max_mult = 10

from math import sqrt
file_old = open(get_project_folder()+'/skript/link_up/'+name+'_old.txt','r')
file_new = open(get_project_folder()+'/skript/link_up/'+name+'_new.txt','r')
file_linked = open(get_project_folder()+'/skript/link_up/'+name+'_lined.txt','w')
content_1 = file_old.readlines()
content_2 = file_new.readlines()
content_matrix_1 = [[content_1[i].split('\t')[j] for j in range(len(content_1[i].split('\t')))] for i in range(len(content_1))] 
content_matrix_2 = [[content_2[i].split('\t')[j] for j in range(len(content_2[i].split('\t')))] for i in range(len(content_2))] 

print('EQUALS\n',file=file_linked)
for j_1 in range(len(content_1)):
    if len(content_matrix_1[j_1]) >= 8:
        count = 0
        for j_2 in range(len(content_2)):
            if len(content_matrix_2[j_2]) >= 8:
                if content_matrix_1[j_1][2] == content_matrix_2[j_2][2] and content_matrix_1[j_1][4] == content_matrix_2[j_2][4] and content_matrix_1[j_1][6] == content_matrix_2[j_2][6] and content_matrix_1[j_1][7] == content_matrix_2[j_2][7] and content_matrix_1[j_1][8].split()[1] == content_matrix_2[j_2][8].split()[1]:
                    mult = round(float(content_matrix_1[j_1][1])*sqrt(float(content_matrix_2[j_2][1])),3)
                    if mult > max_mult:
                        mult = max_mult
                    elif mult < 1/max_mult:
                        mult = max_mult
                    print(content_matrix_1[j_1][0],mult,content_matrix_1[j_1][2],content_matrix_1[j_1][3],content_matrix_1[j_1][4],content_matrix_1[j_1][5],content_matrix_1[j_1][6],content_matrix_1[j_1][7],content_matrix_1[j_1][8].strip(),sep='\t')
                    print(content_matrix_1[j_1][0],mult,content_matrix_1[j_1][2],content_matrix_1[j_1][3],content_matrix_1[j_1][4],content_matrix_1[j_1][5],content_matrix_1[j_1][6],content_matrix_1[j_1][7],content_matrix_1[j_1][8].strip(),sep='\t',file=file_linked)
                    count = 1
        if count == 0:
            print(content_1[j_1].strip())
            print(content_1[j_1].strip(),file=file_linked)

for j_2 in range(len(content_2)):
    if len(content_matrix_2[j_2]) >= 8:
        count = 0
        for j_1 in range(len(content_1)):
            if len(content_matrix_1[j_1]) >= 8:
                if content_matrix_1[j_1][2] == content_matrix_2[j_2][2] and content_matrix_1[j_1][4] == content_matrix_2[j_2][4] and content_matrix_1[j_1][6] == content_matrix_2[j_2][6] and content_matrix_1[j_1][7] == content_matrix_2[j_2][7] and content_matrix_1[j_1][8].split()[1] == content_matrix_2[j_2][8].split()[1]:
                    count = 1
        if count == 0:
            print(content_2[j_2].strip())
            print(content_2[j_2].strip(),file=file_linked)

print('/',file=file_linked)

file_old.close()
file_new.close()
file_linked.close()
---------------------------------------------------------------------------------------------------------------------------------------------
ВЫВОД СЛОВАРЕЙ
---------------------------------------------------------------------------------------------------------------------------------------------
'''
координаты скважин well:(i j)
'''
dict_well_picks = open(get_project_folder()+'/skript/dict/dict_well_picks.txt','w')
dict_well_picks_reverse = open(get_project_folder()+'/skript/dict/dict_well_picks_reverse.txt','w')
well_picks = dict()
well_picks_reverse  = dict()
for m in get_all_models():
    well = ''
    for c in get_all_connections():
        if c.well != str(c.well):
            print(c.well,c.i,c.j)
            well_picks[str(c.well)] = str(c.i)+' '+str(c.j)
            well_picks_reverse[str(c.i)+' '+str(c.j)] = str(c.well)
            well = str(c.well) 
        else:
            continue
print(well_picks,file = dict_well_picks)
print(well_picks_reverse,file = dict_well_picks_reverse)

dict_well_picks.close()
dict_well_picks_reverse.close()
'''
перфорация на горизонты well:(123)
'''
dict_well_perf = open(get_project_folder()+'/skript/dict/dict_well_perf.txt','w')
D0 = set([i for i in range(1,16)])
D1ab = set([i for i in range(18,49)])
D1vgd = set([i for i in range(51,180)])
well_perf = dict()
for m in get_all_models():
    for w in get_all_wells():
        well_layer = set()
        for c in w.connections:
            well_layer.add(c.k)
        well_perf_list = ''
        if D0 & well_layer != set():
            well_perf_list = '1'
        if D1ab & well_layer != set():
            well_perf_list = well_perf_list + '2'
        if D1vgd & well_layer != set():
            well_perf_list = well_perf_list + '3'
        print(w.name,well_perf_list,well_layer)
        well_perf[str(w.name)] = str(well_perf_list)
print(well_perf,file=dict_well_perf)
'''
начало и конец работы добывающей и нагнетательной скважины
'''
dict_prod_working_date_file = open(get_project_folder()+'/skript/dict/dict_prod_working_date.txt','w')
dict_inj_working_date_file = open(get_project_folder()+'/skript/dict/dict_inj_working_date.txt','w')
dict_prod_working_date = dict()
dict_inj_working_date = dict()
for m in get_all_models():
    for w in get_all_wells():
        prod_working_date = []
        inj_working_date = []
        for t in get_all_timesteps():
            if wlprh[m,w,t] > 0:
                prod_working_date.append(t.name)
            if wwirh[m,w,t] > 0:
                inj_working_date.append(t.name)
        if len(prod_working_date)>=2:
            dict_prod_working_date[w.name] = prod_working_date[0]+','+prod_working_date[-1]
        else:
            pass
        if len(inj_working_date)>=2:
            dict_inj_working_date[w.name] = inj_working_date[0]+','+inj_working_date[-1]
        else:
            pass
print(dict_prod_working_date,file=dict_prod_working_date_file)
print(dict_inj_working_date,file=dict_inj_working_date_file)
dict_prod_working_date_file.close()
dict_inj_working_date_file.close()
---------------------------------------------------------------------------------------------------------------------------------------------
ДЛЯ ФОРМАТИРОВАНИЯ ТРАССЕРА
TBLKFB***
123*0 /
---------------------------------------------------------------------------------------------------------------------------------------------

file_open = open(get_project_folder()+'/INCLUDE/skript/file_open.txt','w')
tracer = open(get_project_folder()+'/INCLUDE/tracer.txt','r')
content_1 = tracer.readlines()
content_matrix_1 = [[content_1[i].split('\t')[j] for j in range(len(content_1[i].split('\t')))] for i in range(len(content_1))]  
for i in range(len(content_1)):
    print(content_matrix_1[i][0],file=file_open)
    print(content_matrix_1[i][1],file=file_open)

---------------------------------------------------------------------------------------------------------------------------------------------
ВЫВОД WELL PICKS ПО СКВАЖИНАМ (СОЗДАНИЕ СЛОВОРЯ И ВЫВОД В ФАЙЛ)
---------------------------------------------------------------------------------------------------------------------------------------------

well_picks_dict = open(get_project_folder()+'/INCLUDE/skript/well_picks_dict.txt','w')
for m in get_all_models():
    well_list = ''
    well_pick = {}
    for c in get_all_connections():
        if well_list != str(c.well):
            well_pick[str(c.well)] = str(c.i)+' '+str(c.j)
            well_list = str(c.well)
print(well_pick)
print(well_pick,file=well_picks_dict)
well_picks_dict.close()
#well_picks_dict = open(get_project_folder()+'/INCLUDE/skript/well_picks_dict.txt','r')
#wp = well_picks_dict.read()
#print(wp)
#well_picks_dict.close()

---------------------------------------------------------------------------------------------------------------------------------------------
ОПРЕДЕЛЕНИЕ ЗНАЧЕНИЕ КУБОВ (ПРОНИЦАЕМОСТИ ПО 3 ЗОНАМ) ПО СКВАЖИНАМ
---------------------------------------------------------------------------------------------------------------------------------------------
    
for m in get_all_models():
    permx_d0 = open(get_project_folder()+'/INCLUDE/skript/permx_d0'+'.xyz','r')      
    permx_d1ab = open(get_project_folder()+'/INCLUDE/skript/permx_d1ab'+'.xyz','r')   
    permx_d1vgd = open(get_project_folder()+'/INCLUDE/skript/permx_d1vgd'+'.xyz','r')
    content_1 = permx_d0.readlines()
    content_matrix_1 = [[content_1[i].split('\t')[j] for j in range(len(content_1[i].split('\t')))] for i in range(len(content_1))]  
    content_2 = permx_d1ab.readlines()
    content_matrix_2 = [[content_2[i].split('\t')[j] for j in range(len(content_2[i].split('\t')))] for i in range(len(content_2))]  
    content_3 = permx_d1vgd.readlines()
    content_matrix_3 = [[content_3[i].split('\t')[j] for j in range(len(content_3[i].split('\t')))] for i in range(len(content_3))]  
    #print(len(content_1))
    permx_1 = {str(content_matrix_1[i][0])+' '+str(content_matrix_1[i][1]): content_matrix_1[i][2] for i in range(len(content_1))}
    permx_2 = {str(content_matrix_2[i][0])+' '+str(content_matrix_2[i][1]): content_matrix_2[i][2] for i in range(len(content_2))}
    permx_3 = {str(content_matrix_3[i][0])+' '+str(content_matrix_3[i][1]): content_matrix_3[i][2] for i in range(len(content_3))}
    #print(permx_1)
    for c in get_all_connections():
        if str(c.well) == '84':
            print(round(float(permx_1[str(c.i)+' '+str(c.j)].split('\n')[0]),1))
            print(round(float(permx_2[str(c.i)+' '+str(c.j)].split('\n')[0]),1))
            print(round(float(permx_3[str(c.i)+' '+str(c.j)].split('\n')[0]),1))
            break

---------------------------------------------------------------------------------------------------------------------------------------------
ДАТА   СР_ДАВЛЕНИЕ   НАК_КОМП   ТЕК_КОМП
---------------------------------------------------------------------------------------------------------------------------------------------

for m in get_all_models():
    for t in get_all_timesteps():
        print(t.name,round(FPR[m,t].to_list()[0],1),round((FVPT[m,t]/FVIT[m,t]).to_list()[0],2),round((FVPR[m,t]/FVIR[m,t]).to_list()[0],2))

---------------------------------------------------------------------------------------------------------------------------------------------
ДЛЯ ИЛЮХИ - ВИЗУАЛИЗАЦИЯ ДЕБИТОВ И ПРИЕМИСТОСТИ ПО СКВАЖИНАМ (ДАТА 1 ДАТА 2)
---------------------------------------------------------------------------------------------------------------------------------------------

d1_year = 2010
d2_year = 2014
tapir_file = open(get_project_folder()+'/tapir_file.xls','w')
print('Скважина','Дата','Дебит_нефти,м3/сут','Дебит_воды,м3/сут','Дебит_жидкости,м3/сут','Приемистость,м3/сут')
print('Скважина','Дата','Дебит_нефти,м3/сут','Дебит_воды,м3/сут','Дебит_жидкости,м3/сут','Приемистость,м3/сут',file=tapir_file)
for m in get_all_models():
    for w in get_all_wells():
        for t in get_all_timesteps():
            dt = t.to_datetime()
            if dt.year >= d1_year and dt.year <= d2_year and (wopr[m,w,t].to_list()[0] > 0 or wwir[m,w,t].to_list()[0] > 0):
                print(w.name,t.name,round(wopr[m,w,t].to_list()[0],1),round(wwpr[m,w,t].to_list()[0],1),round(wlpr[m,w,t].to_list()[0],1),round(wwir[m,w,t].to_list()[0],1))
                print(w.name,t.name,round(wopr[m,w,t].to_list()[0],1),round(wwpr[m,w,t].to_list()[0],1),round(wlpr[m,w,t].to_list()[0],1),round(wwir[m,w,t].to_list()[0],1),file=tapir_file)
tapir_file.close()

---------------------------------------------------------------------------------------------------------------------------------------------
ДЛЯ АЛЬБЕРТА - РАЗНИЦА В НАКОПЕННОЙ НЕФТИ (ДАТА 1 ДАТА 2)
---------------------------------------------------------------------------------------------------------------------------------------------

date_1 = '01.11.2013'
date_2 = '01.02.2015'

for m in get_all_models():
    for t in get_all_timesteps():
        if t.name == date_1:
            t_date_1 = t
        if t.name == date_2:
            t_date_2 = t
        
print('well#','\t','Абс.невязка','\t','Отн.невязка')
oil_prod_date_diff = open(get_project_folder()+'/oil_prod_date_diff.txt','w')
for m in get_all_models():
    for w in get_all_wells():
        well_fix_oil_prod_hist_1 = WOPTH[m,w,t_date_1].to_list()[0]
        well_fix_oil_prod_hist_2 = WOPTH[m,w,t_date_2].to_list()[0]
        well_fix_oil_prod_1 = WOPT[m,w,t_date_1].to_list()[0]
        well_fix_oil_prod_2 = WOPT[m,w,t_date_2].to_list()[0]
        diff_hist = well_fix_oil_prod_hist_2 - well_fix_oil_prod_hist_1
        diff_calc = well_fix_oil_prod_2 - well_fix_oil_prod_1
        diff_abs = diff_hist - diff_calc
        if diff_hist != 0:
            diff = abs(diff_hist - diff_calc)*100/diff_hist
        else:
            diff = 0
        print(w.name,'\t',round(diff_abs,1),'\t',round(diff,1))
        print(w.name,round(diff_abs,1),round(diff,1),file=oil_prod_date_diff)
#        print(w.name,well_fix_oil_prod_hist_1,well_fix_oil_prod_hist_2,well_fix_oil_prod_1,well_fix_oil_prod_2)
oil_prod_date_diff.close()

---------------------------------------------------------------------------------------------------------------------------------------------
НАХОЖДЕНИЕ ОШИБКИ В ИСТОРИИ (ЕСТЬ ДОБЫЧА, НО НЕТ ПЕРФОРАЦИИ) 
---------------------------------------------------------------------------------------------------------------------------------------------

ts_list = [*get_all_timesteps ()]
ts_count = len (ts_list)

err_liq_prod = open(get_project_folder()+'/skript/hist/err_liq_prod.inc','w')
err_wat_inj = open(get_project_folder()+'/skript/hist/err_wat_inj.inc','w')

for m in get_all_models():
  for w in get_all_wells():
      oil_prod = WLPRH[m,w].to_list()
      wat_inj = WWIRH[m,w].to_list()
      sum_perf = WMCON[m,w].to_list()
      sum_wat_inj = sum_oil_prod = 0
      for t in range(ts_count):
          if wat_inj[t] > 0 and sum_perf[t] == 0:
              sum_wat_inj = sum_wat_inj + wat_inj[t]
          if oil_prod[t] > 0 and sum_perf[t] == 0:              
              sum_oil_prod = sum_oil_prod + oil_prod[t]
      if sum_wat_inj > 0:
          print(w.name,'INJ',round(sum_wat_inj,1))
          print(w.name,round(sum_wat_inj,1),file = err_wat_inj)
      if sum_oil_prod > 0:
          print(w.name,'PROD',round(sum_oil_prod,1))
          print(w.name,round(sum_oil_prod,1),file = err_liq_prod)               

err_liq_prod.close()
err_liq_prod.close()

---------------------------------------------------------------------------------------------------------------------------------------------
НАХОЖДЕНИЕ ОШИБКИ В ИСТОРИИ (СКАЧЕК ПО ЖИДКОСТИ) 10*AV_LIQ < RATE_LIQ
---------------------------------------------------------------------------------------------------------------------------------------------
mult = 10
well_list = {''} # список скважин с некорректной историей

file_hist_new = open(get_project_folder()+'/skript/hist/hist_new.txt','w')

producer_mask = (WSTAT == 1)
liquid_prod = WLPRH * (WSTAT == 1)

sum_l_prod = liquid_prod.sum (dates='all')
prod_dates = producer_mask.sum (dates='all')

avg_l_prod = if_then_else (sum_l_prod > 0, sum_l_prod / prod_dates , 0)
export (avg_l_prod, name = "avg_l_prod")

big_hist = WLPRH * (WLPRH > mult * avg_l_prod) *(avg_l_prod > 0)
export (big_hist, name = "big_hist")

ts_list = [*get_all_timesteps ()]
ts_count = len (ts_list)
for m in get_all_models():
  for w in get_all_wells():
    well_check = set() 
    well_check.add(w.name) 
    avg = float (avg_l_prod[m,w])
    avg_mult = avg * mult;
    hist_l = WLPRH[m,w].to_list ()
    oil_hist = WOPRH[m,w].to_list ()
    water_hist = WWPRH[m,w].to_list ()
    inj_hist = WWIRH[m,w].to_list ()
    BHPH_hist = WBHPH[m,w].to_list ()
    THPH_hist = WTHPH[m,w].to_list ()
    WOF_hist = WEFF[m,w].to_list ()
    if avg > 0:
      for i_step in range (ts_count):
        if hist_l[i_step] > avg_mult and well_check & well_list == set():
            print (w.name, ts_list[i_step-1].name,round(oil_hist[i_step]*WOF_hist[i_step],2),round(water_hist[i_step]*WOF_hist[i_step],2),inj_hist[i_step]*WOF_hist[i_step],BHPH_hist[i_step],THPH_hist[i_step],'1.00 --',WOF_hist[i_step],sep='\t',file=file_hist_new)
            print (w.name, ts_list[i_step-1].name,round(oil_hist[i_step]*WOF_hist[i_step],2),round(water_hist[i_step]*WOF_hist[i_step],2),inj_hist[i_step]*WOF_hist[i_step],BHPH_hist[i_step],THPH_hist[i_step],'1.00 --',WOF_hist[i_step],sep='\t')
file_hist_new.close()

'''
ПЕРЕЗАПИСЬ ИСТОРИИ -- ЗАПИСЬ ПРОИСХОДИТ В ФАЙЛ hist_fixed.inc
'''
start_line = 15

file_hist_fixed = open(get_project_folder()+'/skript/hist/hist_fixed.txt','w')
file_hist_new = open(get_project_folder()+'/skript/hist/hist_new.txt','r')
file_hist = open(get_project_folder()+'/INCLUDE/hist.inc','r')

content_new = file_hist_new.readlines()
content = file_hist.readlines()

content_new_matrix = [[content_new[i_n].split('\t')[j_n] for j_n in range(len(content_new[i_n].split('\t')))] for i_n in range(len(content_new))]
content_matrix = [[content[i].split('\t')[j] for j in range(len(content[i].split('\t')))] for i in range(len(content))]

for i in range(start_line):
    file_hist_fixed.write(content[i])

for m in range(start_line,len(content)):
    k = 0
    for n in range(len(content_new)):
        if content_new_matrix[n][0] == content_matrix[m][0] and content_new_matrix[n][1] == content_matrix[m][1]:
            k = 1
            file_hist_fixed.write(content_new_matrix[n][0]+'\t'+content_new_matrix[n][1]+'\t'+content_new_matrix[n][2]+'\t'+content_new_matrix[n][3]+'\t'+content_new_matrix[n][4]+'\t'+content_new_matrix[n][5]+'\t'+content_new_matrix[n][6]+'\t'+'1.00'+'\n')            
    if k != 1:
        file_hist_fixed.write(content_matrix[m][0]+'\t'+content_matrix[m][1]+'\t'+content_matrix[m][2]+'\t'+content_matrix[m][3]+'\t'+content_matrix[m][4]+'\t'+content_matrix[m][5]+'\t'+content_matrix[m][6]+'\t'+content_matrix[m][7]+'\n')

file_hist.close()
file_hist_new.close()
file_hist_fixed.close()

---------------------------------------------------------------------------------------------------------------------------------------------
Создание средних давлений по группам скважин
---------------------------------------------------------------------------------------------------------------------------------------------

gwbp_av = graph (type = 'group', default_value = 0)
for m in get_all_models ( ):
    for g in get_all_groups ( ):
        count = 0
        for w in g.wells:
            gwbp_av[m,g] += wbp[m,w]
            count += 1
        gwbp_av[m,g] /= count
gwbp_av = gwbp_av

---------------------------------------------------------------------------------------------------------------------------------------------
Какая часть дебита скважин идет из слоев сетки D0 = 1-16 / D1ab = 18-50 / D1vgd = 51-180
---------------------------------------------------------------------------------------------------------------------------------------------

tmp1 = graph (type = 'well', default_value = 0)
tmp2 = graph (type = 'well', default_value = 0)
tmp3 = graph (type = 'well', default_value = 0)
for c in get_all_connections():
    if c.k in range(1,16):
        tmp1[c.well] += copr[c] #copr дебит нефти в перфорации
    if c.k in range(18,50):
        tmp2[c.well] += copr[c]
    if c.k in range(51,180):
        tmp3[c.well] += copr[c]    
export(tmp1/wopr, name = 'PROD_D0/D') #wopr дебит нефти скважины 
export(tmp2/wopr, name = 'PROD_D1ab/D')
export(tmp3/wopr, name = 'PROD_D1vgd/D')

---------------------------------------------------------------------------------------------------------------------------------------------
Средний дебит нефти для подмножиства скважин (название начинается с WELL1)
---------------------------------------------------------------------------------------------------------------------------------------------

s = ','.join([x.name for x in get_wells_by_mask('1*')])
obs = wopr.avg(objects = s)
inpf = open (get_project_folder() + '/input.txt','r')
arr = [(line.split()[0],float(line.split()[1])) for line in inpf]
hist = create_table_vs_time(arr)
export((obs - hist)**2, name = 'fuobj')

---------------------------------------------------------------------------------------------------------------------------------------------
Интерполяция данных пластовых и забойных давлений
---------------------------------------------------------------------------------------------------------------------------------------------

BHPress = graph (type = 'well', default_value = 0)
RPress = graph (type = 'well', default_value = 0)
#BHPress_fixed = graph (type = 'well', default_value = 0)
#RPress_fixed = graph (type = 'well', default_value = 0)
for m in get_all_models():
    for w in get_all_wells():
        current_BHP = wbhph[m,w]
        current_RP = WTHPH[m,w]
        observed_BHP = []
        observed_RP = []
        for t in get_all_timesteps():
            if current_BHP[t] > 10 and w.is_opened:
                observed_BHP.append ((t.name, float(current_BHP[t])))
            if current_RP[t] > 10 and w.is_opened:
                observed_RP.append ((t.name, float(current_RP[t])))
        if len (observed_BHP) >= 2:
            BHPress[m,w] = create_table_vs_time(observed_BHP)
        if len (observed_RP) >= 2:
            RPress[m,w] = create_table_vs_time(observed_RP)
#        for t in get_all_timesteps():
#            BHPress_fixed[m,w,t] = BHPress[m,w,t].to_list()[0]
#            RPress_fixed[m,w,t] = RPress[m,w,t].to_list()[0]
#            if WSTAT[m,w,t].to_list()[0] != 1 or WSTAT[m,w,t].to_list()[0] != 2: 
#                print(w.name,t.name,WSTAT[m,w,t].to_list()[0],BHPress[m,w,t].to_list()[0],RPress[m,w,t].to_list()[0])
#                BHPress_fixed[m,w,t] = 0
#                RPress_fixed[m,w,t] = 0               
#                BHPress[m,w,t] = 0
#                RPress[m,w,t] = 0
export(BHPress, name = 'BHPress')
export(RPress, name = 'RPress')
#export(BHPress_fixed, name = 'BHPress_fixed')
#export(RPress_fixed, name = 'RPress_fixed')

---------------------------------------------------------------------------------------------------------------------------------------------
Степень адаптации
---------------------------------------------------------------------------------------------------------------------------------------------
#group_name = {'D0','D1','D01','MAIN'}
group_name = {'MAIN'}

K_adapt = open(get_project_folder()+'/skript/K_adapt.txt','a')

import datetime
now = datetime.datetime.now()
 
print (now.strftime("%d-%m-%Y %H:%M"),file = K_adapt)    

for m in get_all_models():  
    if float(FLPTH[m].max(dates='all').to_list()[0]) > 0:
        for g in get_all_groups():
            group_set = set()
            group_set.add(g.name)
            if group_set & group_name:
                print('-----------------------------------------------',g.name,'-----------------------------------------------')
                print('-----------------------------------------------',g.name,'-----------------------------------------------',file = K_adapt)
                count_all = count = sum_well_prod_adapt_g = dif_oil_abs_g = 0
                for w in g.wells:
                    oilhist = float(wopth[m,w].max(dates='all').to_list()[0])
                    oilcalc = float(wopt[m,w].max(dates='all').to_list()[0])
    #                print(float(str(oilhist).split('\n ')[0]))
                    if oilhist > 0: 
                        adapt = (oilhist-oilcalc)*100/oilhist
                        dif_oil_abs_g = abs(oilhist-oilcalc) + dif_oil_abs_g
                        if abs(adapt) < 20:
                            sum_well_prod_adapt_g = sum_well_prod_adapt_g + oilhist             #НАКОПЛЕННАЯ НЕФТЬ САДАПТИРОВАННЫХ СКВАЖИН
                            count = count + 1
#                            print(w.name)
                        count_all = count_all + 1
                GLP_h_last = float(GLPTH[m,g].max (dates='all').to_list()[0])                   #НАКОПЛЕННАЯ ЖИДКОСТЬ И
                GLP_last = float(GLPT[m,g].max (dates='all').to_list()[0])                      #НАКОПЛЕННАЯ ЖИДКОСТЬ 
                GOP_h_last = float(GOPTH[m,g].max (dates='all').to_list()[0])                   #НАКОПЛЕННАЯ НЕФТЬ И
                GOP_last = float(GOPT[m,g].max (dates='all').to_list()[0])                      #НАКОПЛЕННАЯ НЕФТЬ
                total_sum_well_prod_adapt_g = sum_well_prod_adapt_g*100/GOP_h_last 
                liq_dif_last_g = (GLP_h_last - GLP_last)*100/GLP_h_last
                oil_dif_last_g = (GOP_h_last - GOP_last)*100/GOP_h_last
                total_adapt = count / count_all
                
                print ('Количество садаптированных скважин:',round(total_adapt*100,1),'%'+' (',count,'из',count_all,')')
                print ('Добыча садаптированных скважин к добыче всех скважин:',round(total_sum_well_prod_adapt_g,1),'%')
                print ('Интегральная адаптация жидкости last date:',round(100-liq_dif_last_g,1),'%','(',round((GLP_h_last-GLP_last)/1000,1),'тыс.т )')
                print ('Интегральная адаптация нефти last date:',round(100-oil_dif_last_g,1),'%','(',round((GOP_h_last-GOP_last)/1000,1),'тыс.т )')
                print ('Разница в процетах от накопленной добычи: {} % ({}/{}={} тыс.т./скв)'.format(round(dif_oil_abs_g*100/GOP_h_last,1),round(dif_oil_abs_g/1000,1),count_all,round(dif_oil_abs_g/1000/count_all,1)),'\n')
                
                print ('Количество садаптированных скважин:',round(total_adapt*100,1),'%','(',count,'из',count_all,')',file = K_adapt)
                print ('Добыча садаптированных скважин к добыче всех скважин:',round(total_sum_well_prod_adapt_g,1),'%',file = K_adapt)
                print ('Интегральная адаптация жидкости last date:',round(100-liq_dif_last_g,1),'%','(',round((GLP_h_last-GLP_last)/1000,1),'тыс.т )',file = K_adapt)
                print ('Интегральная адаптация нефти last date:',round(100-oil_dif_last_g,1),'%','(',round((GOP_h_last - GOP_last)/1000,1),'тыс.т )','\n',file = K_adapt) 
                print ('Разница в процетах от накопленной добычи: {} % ({}/{}={} тыс.т./скв)'.format(round(dif_oil_abs_g*100/GOP_h_last,1),round(dif_oil_abs_g/1000,1),count_all,round(dif_oil_abs_g/1000/count_all,1)),'\n',file = K_adapt)
        
        print('-----------------------------------------------','FIELD','-----------------------------------------------')
        print('-----------------------------------------------','FIELD','-----------------------------------------------',file = K_adapt)

for m in get_all_models():
    if float(FLPTH[m].max(dates='all').to_list()[0]) > 0:
        count_all_f = count_f = sum_well_prod_adapt = sum_well_prod_hist = dif_oil_abs_f = 0
        for w in get_all_wells():
            oilhist = float(wopth[m,w].max(dates='all').to_list()[0])
            oilcalc = float(wopt[m,w].max(dates='all').to_list()[0])
        #    print(float(str(oilhist).split(' ')[4]))
            if oilhist > 0: 
                adapt_f = (oilhist-oilcalc)*100/oilhist
                dif_oil_abs_f = abs(oilhist-oilcalc) + dif_oil_abs_f
                if abs(adapt_f) < 20:
#                    print(w.name)
                    sum_well_prod_adapt = sum_well_prod_adapt + oilhist
                    count_f = count_f + 1
                count_all_f = count_all_f + 1
                sum_well_prod_hist = sum_well_prod_hist + oilhist ###
        total_adapt_f = count_f / count_all_f
    
        FLP_h_last = float(FLPTH[m].max(dates='all').to_list()[0])
        FLP_last = float(FLPT[m].max(dates='all').to_list()[0])
        FOP_h_last = float(FOPTH[m].max(dates='all').to_list()[0])
        FOP_last = float(FOPT[m].max(dates='all').to_list()[0])
        total_sum_well_prod_adapt = sum_well_prod_adapt*100/sum_well_prod_hist                        #sum_well_prod_hist
        liq_dif_last = (FLP_h_last - FLP_last)*100/FLP_h_last
        oil_dif_last = (FOP_h_last - FOP_last)*100/FOP_h_last
        print ('Количество садаптированных скважин:',round(total_adapt_f*100,1),'%','(',count_f,'из',count_all_f,')')
        print ('Добыча садаптированных скважин к добыче всех скважин:',round(total_sum_well_prod_adapt,1),'%')
        print ('Интегральная адаптация жидкости last date:',round(100-liq_dif_last,1),'%','(',round((FLP_h_last-FLP_last)/1000,1),'тыс.т )')
        print ('Интегральная адаптация нефти last date:',round(100-oil_dif_last,1),'%','(',round((FOP_h_last-FOP_last)/1000,1),'тыс.т )')
        print ('Разница в процетах от накопленной добычи: {} % ({}/{}={} тыс.т./скв)'.format(round(dif_oil_abs_f*100/sum_well_prod_hist,1),round(dif_oil_abs_f/1000),count_all_f,round(dif_oil_abs_f/1000/count_all_f,1)),'\n')
    
        print ('Количество садаптированных скважин:',round(total_adapt_f*100,1),'%','(',count_f,'из',count_all_f,')',file = K_adapt)
        print ('Добыча садаптированных скважин к добыче всех скважин:',round(total_sum_well_prod_adapt,1),'%',file = K_adapt)
        print ('Интегральная адаптация жидкости last date:',round(100-liq_dif_last,1),'%','(',round((FLP_h_last-FLP_last)/1000,1),'тыс.т )',file = K_adapt)
        print ('Интегральная адаптация нефти last date:',round(100-oil_dif_last,1),'%','(',round((FOP_h_last-FOP_last)/1000,1),'тыс.т )',file = K_adapt)
        print ('Разница в процетах от накопленной добычи: {} % ({}/{}={} тыс.т./скв)'.format(round(dif_oil_abs_f*100/sum_well_prod_hist,1),round(dif_oil_abs_f/1000),count_all_f,round(dif_oil_abs_f/1000/count_all_f,1)),'\n',file = K_adapt)
     
---------------------------------------------------------------------------------------------------------------------------------------------
Степень адаптации  -- ТИМУР
---------------------------------------------------------------------------------------------------------------------------------------------

date = '01.03.2018'
woprodhsum = 0 #суммарная добыча по истории
awoprod = 0 #суммарная добыча по адаптированным
nawells = ''

for w in get_all_wells():
    woprod = wopt.max(objects=str(w),dates=date)
    #woprod=float(str(woprod).split(' ')[4])
    woprodh = wopth.max(objects=str(w),dates=date)
    #woprodh=float(str(wopth.max(objects=str(w),dates=date)).split(' ')[4])

    err = (woprodh-woprod)/woprodh*100
    err = float(str(err).split(' ')[4])

    woprodhsum += woprodh
    if abs(err)<20:
        awoprod += woprodh
    else:
        nawells += ' ' + str(w)
        
print ('Процент садаптированных скважин по нефти',awoprod/woprodhsum*100)
print ('Вылетающие скважины:')
print (nawells)
result = awoprod/woprodhsum*100

---------------------------------------------------------------------------------------------------------------------------------------------
mult  -- ТИМУР
---------------------------------------------------------------------------------------------------------------------------------------------
#Вставить текст в Калькулятор графиков окна Шаблон графиков.
#Задать имя мульта и максимальное количество слоёв модели

mult='_D' #Имя мульта
k=180        #Количество слоёв k

import os

#запись файла и создание папки, если её нет
if 'RESULTS' in get_project_folder():
    file_path=get_project_folder().split('RESULTS')[0]+'USER/'
else:
    file_path=get_project_folder()+'/USER/'

if not os.path.exists(file_path):
    os.makedirs(file_path)

filename=file_path+'arr'+mult+'.txt'
#проверка, нет ли такого файла
if os.path.exists(filename): 
   print ('Полегче, файл '+filename+' уже существует, уверен(а), что хочешь его перезаписать?')
else:
    fileh=open(filename,'w')

#Запись в файл
    head='EQUALS\n'+'arr'+mult+' 0 /\n'
    fileh.write(head+'\n')

    well_before=''
    for c in get_all_connections():
        well=str(c.well)
        if well!=well_before:
            line='arr{0} 1 {1} {1} {2} {2} 1 {3} /-- {4}     \n'.format(mult,c.i,c.j,k,well)
            fileh.write(line)
        well_before=str(c.well)

    fileh.write('/'+'\n')
    fileh.write('ARITHMETIC'+'\n')
    fileh.write('arr{0}=interpolate_ML_IDW(arr{0},    0,1,4)'.format(mult)+'\n')
    fileh.write('/')
    fileh.close()

mult=1

---------------------------------------------------------------------------------------------------------------------------------------------
ARR_KRWR
---------------------------------------------------------------------------------------------------------------------------------------------
''' # СТАРЫЙ СКРИПТ
file_KRWR = open(get_project_folder()+'/skript/ARR_KRWR.txt','w')
print('EQUALS')
file_KRWR.write('EQUALS'+'\n')

max_mult = 2

MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}

D0 = set([i for i in range(1,16)])
D1ab = set([i for i in range(18,49)])
D1vgd = set([i for i in range(51,180)])

well_before = ''
perf = ''
for m in get_all_models():
    for c in get_all_connections():
        well = str(c.well)
        if perf == '':
            perf = str(c.k)
            well_before = well
            continue
        elif well != well_before:
            woprod = wopt[m].max(objects=str(well_before),dates='all')
            woprodh = wopth[m].max(objects=str(well_before),dates='all')
            mult = woprod/woprodh
            mult = float(str(mult).split(' ')[4])
            if mult > max_mult:
                mult = max_mult
            if mult < 1/max_mult:
                mult = 1/max_mult
            w_perf = [int(p) for p in perf.split(',')]
            check_perf = set(w_perf)
            
            if check_perf&D0 != set() and mult != 0:
                print('ARR_KRWR',round(mult,3),x,x,y,y,min(D0),max(D0),'/--', well_before,'D0',check_perf&D0)
                file_KRWR.write('ARR_KRWR '+str(round(mult,3))+' '+str(x)+' '+str(x)+' '+str(y)+' '+str(y)+' '+str(min(D0))+' '+str(max(D0))+' /-- '+str(well_before)+' D0 '+str(check_perf&D0)+'\n')
            if check_perf&D1ab != set() and mult != 0:
                print('ARR_KRWR',round(mult,3),x,x,y,y,min(D1ab),max(D1ab),'/--', well_before,'D1ab',check_perf&D1ab)
                file_KRWR.write('ARR_KRWR '+str(round(mult,3))+' '+str(x)+' '+str(x)+' '+str(y)+' '+str(y)+' '+str(min(D1ab))+' '+str(max(D1ab))+' /-- '+str(well_before)+' D1ab '+str(check_perf&D1ab)+'\n')
            if check_perf&D1vgd != set() and mult != 0:
                print('ARR_KRWR',round(mult,3),x,x,y,y,min(D1vgd),max(D1vgd),'/--', well_before,'D1vgd',check_perf&D1vgd)
                file_KRWR.write('ARR_KRWR '+str(round(mult,3))+' '+str(x)+' '+str(x)+' '+str(y)+' '+str(y)+' '+str(min(D1vgd))+' '+str(max(D1vgd))+' /-- '+str(well_before)+' D1vgd '+str(check_perf&D1vgd)+'\n')
            
            perf = ''
            perf = str(c.k)
        else:
            perf = perf+','+str(c.k)
        well_before = well
        x = c.i
        y = c.j
        z = c.k

print('/')    

file_KRWR.write('/')
file_KRWR.close()

file_KRWR = open(get_project_folder()+'/INCLUDE/ARR_KRWR.txt','r')
print(file_KRWR.readline(3))
file_KRWR.close()
'''
MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}
max_mult = 2
file_KRWR = open(get_project_folder()+'/skript/ARR_KRWR.txt','w')
dict_well_picks = open(get_project_folder()+'/skript/dict/dict_well_picks.txt','r')
dict_well_perf = open(get_project_folder()+'/skript/dict/dict_well_perf.txt','r')
well_picks = eval(dict_well_picks.read())
well_perf = eval(dict_well_perf.read())
print('EQUALS\n',file=file_KRWR)
for m in get_all_models():
    for w in get_all_wells():
            woprod = wopt[m,w].max(dates='all')
            woprodh = wopth[m,w].max(dates='all')
            if woprodh > 0:
                mult = round((woprod/woprodh).to_list()[0],2)
                if mult > max_mult:
                    mult = max_mult
                elif mult < 1/max_mult:
                    mult = 1/max_mult
                x = int(well_picks[str(w.name)].split(' ')[0])
                y = int(well_picks[str(w.name)].split(' ')[1])
                for k,v in MODEL_CELLS.items():
                    for i in set(well_perf[w.name]):
                        if set(k)&set(i)!=set():
                            print('ARR_KRWR',mult,x,x,y,y,int(v.split(',')[0]),int(v.split(',')[1]),'/ %s perf %s' %(w.name,well_perf[w.name]),sep='\t')
                            print('ARR_KRWR',mult,x,x,y,y,int(v.split(',')[0]),int(v.split(',')[1]),'/ %s perf %s' %(w.name,well_perf[w.name]),sep='\t',file=file_KRWR)
print('/',file=file_KRWR)
---------------------------------------------------------------------------------------------------------------------------------------------
ARR_MULT
---------------------------------------------------------------------------------------------------------------------------------------------
"""
НАХОЖДЕНИЕ ОШИБКИ В ИСТОРИИ (СКАЧЕК ПО ЖИДКОСТИ)
"""
for m in get_all_models():
    for w in get_all_wells():
        ALRH = 0     
        count = 0
        for t in get_all_timesteps():
            if w.is_producer()[m,t] == 1:
                ALRH = float(str(WLPRH[m,w,t]).split('\n')[0]) + ALRH
                count = count + 1
        if count != 0:
            ALRH = ALRH/count
            print(w.name,round(ALRH,1))
            for t in get_all_timesteps():
                CLRH = float(str(WLPRH[m,w,t]).split('\n')[0])
                if CLRH > 10*ALRH:
                    print(w.name,t.name,round(CLRH,1))
"""            
МУЛЬТ НА ЖИДКОСТЬ/ЗАКАЧКУ ВОДЫ
"""
max_mult = 3
min_mult = 1.02

from math import sqrt
well_list = {''} # список скважин на которых не влияет мульты
for m in get_all_models():
    for w in get_all_wells():
        well_check = set()
        well_check.add(w.name)
        TLH = WLPTH[m,w].max(dates='all')
        TLH = float(TLH.to_list()[0])
        TL = WLPT[m,w].max(dates='all')
        TL = float(TL.to_list()[0])
        if TLH > 0 and TL > 0 and TLH != TL and well_check & well_list == set():
            mult1 = TLH/TL
            if mult1 > max_mult:
                mult1 = max_mult
            if mult1 > min_mult:
                print('prod',w.name,round(mult1,3),sep='\t')#,well_check,well_list)             #МУЛЬТ НА ДОБЫВАЮЩИЕ СКВАЖИНЫ

           
        TIH = WWITH[m,w].max(dates='all')
        TIH = float(TIH.to_list()[0])
        TI = WWIT[m,w].max(dates='all')
        TI = float(TI.to_list()[0])
        if TIH > 0 and TIH != TI:
            mult2 = TIH/TI
            print('inj',w.name,round(sqrt(mult2),3),sep='\t')                               #МУЛЬТ НА НАГНЕТАТЕЛЬНЫЕ СКВАЖИНЫ
        if TLH > 0 and TLH != TL:
            if TIH > 0 and TIH != TI:
                print('mix',w.name,round(sqrt(mult1*mult2),3),sep='\t')
       
"""      
УСТАНОВКА МУЛЬТИПЛИКАТОРА ПО ПЛАСТОВОМУ И ЗАБОЙНОМУ ДАВЛЕНИЮ 
"""
from math import sqrt

BHP = graph (type = 'well', default_value = 0)
RP = graph (type = 'well', default_value = 0)
for m in get_all_models():
    for w in get_all_wells():
        current_BHP = wbhph[m,w]
        current_RP = WTHPH[m,w]
        observed_BHP = []
        observed_RP = []
        for t in get_all_timesteps():
            if current_BHP[t] > 10 and w.is_opened:
                observed_BHP.append ((t.name, float(current_BHP[t])))
            if current_RP[t] > 10 and w.is_opened:
                observed_RP.append ((t.name, float(current_RP[t])))
        if len (observed_BHP) >= 2:
            BHP[m,w] = create_table_vs_time(observed_BHP)
        if len (observed_RP) >= 2:
            RP[m,w] = create_table_vs_time(observed_RP)
export(BHP, name = 'bhp')
export(RP, name = 'rp')
"""
for m in get_all_models():
    for w in get_all_wells():
        for t in get_all_timesteps():
            print(w.name,t.name,float(str(RP[m,w,t]).split(' \n')[0]),float(str(BHP[m,w,t]).split(' \n')[0]))
"""
model = 'BEREZKA_COARSEN'
for w in get_all_wells():
    s1 = 0
    s2 = 0
    s3 = 0
    s4 = 0
    c = 0
    for t in get_all_timesteps():
#        if float(str(w.is_producer()).split(' ')[4])==1:
        if w.is_producer:
            
            BHP_hist = float(str(BHP[w,t]).split(' ')[4])
            RP_hist = float(str(RP[w,t]).split(' ')[4])
            BHP_calc = float(str(WBHP[w,t]).split(' ')[4])
            PP_calc = float(str(WBP9[w,t]).split(' ')[4])
            if float(str(BHP[w,t]).split(' ')[4]) != 0 and float(str(RP[w,t]).split(' ')[4]) and BHP_calc != 0 and PP_calc != 0:
                s1 = s1 + float(str(BHP[w,t]).split(' ')[4])
                s2 = s2 + float(str(RP[w,t]).split(' ')[4])
                s3 = s3 + BHP_calc
                s4 = s4 + PP_calc
                c = c + 1
#            print(w.name,t.name,float(str(RP[w,t]).split(' ')[4]),float(str(BHP[w,t]).split(' ')[4]),BHP_calc,PP_calc)
    if c != 0:
        av_BHP_hist = s1/c
        av_PP_hist = s2/c
        av_BHP_calc = s3/c
        av_PP_calc = s4/c
#    if av_PP_calc != av_BHP_calc or av_BHP_hist!=-999 or av_PP_hist!=-999 or av_BHP_calc!=-999 or av_PP_calc!=-999:
#    print('Pпл(И)   Pз(И)   Pпл   Pз')

    try:
        mult2 = (av_PP_calc - av_BHP_calc)/(av_PP_hist - av_BHP_hist)
        print(w.name,round(av_PP_hist,1),round(av_BHP_hist,1),round(av_PP_calc,1),round(av_BHP_calc,1))
    except:
        mult2 = 1
        print(w.name,'NA')
    print(w.name,mult2/abs(mult2)*round(sqrt(abs(mult2)),3))

------------------------------------
for m in get_all_models():
    for w in get_all_wells():
        for t in get_all_timesteps():
            print(w.name,t.name,w.is_producer()[m,w,t])

---------------------------------------------------------------------------------------------------------------------------------------------
АДАПТАЦИЯ ПЛАСТОВОГО ДАВЛЕНИЯ
---------------------------------------------------------------------------------------------------------------------------------------------
"""
ИСПРАВЛЯЕМ ИСТОРИЮ ПО ПЛАСТОВОМУ И ЗАБОЙНОМУ ДАВЛЕНИЯМ
"""
for m in get_all_models():
    for w in get_all_wells():
        for t in get_all_timesteps():
            if float(WBHPH[m,w,t]) > 500
                print(w.name,t.name,float(WBHPH[m,w,t]))
            if float(str(WTHPH[m,w,t])) > 500
                print(w.name,t.name,float(WTHPH[m,w,t]))            

"""
ОПРЕДЕЛЯЕМ КОЭФФИЦИЕНТ ВЗАИМОДЕЙСТВИЯ
"""
#influence_well_inj = open(get_project_folder()+'/INCLUDE/skript/influence_well_inj.txt','w')

from math import sqrt
a = 50 # размер ячейки
l = 3000/a # расстояние в ячейках 
L = l*10 # максимальное расстояние 
print('well_1','well_2','length','coefficient') 

for m in get_all_models():
    p_well_1 = ''
    for c in get_all_connections():  
        w_list_2 = set()         
        c_well = c.well
        if str(c.well) != str(p_well_1):
            influence_well_inj = open(get_project_folder()+'/INCLUDE/skript/influence_well_inj/'+str(c.well)+'.txt','w') 
            x = c.i
            y = c.j
            well = c.well
            p_well_2 = ''
            for c in get_all_connections():          
                if (c.i == x) and (c.j == y):
                   k = L 
#                elif (str(c.well) != str(p_well_2)) and (str(c.well) != str(well)) and r < l:
                elif str(c.well) != str(well) and str(p_well_2) != str(c.well) and ((c.i >= x - l/2) and (c.i <= x + l/2)) and ((c.j >= y - l/2) and (c.j <= y + l/2)):
                    r = sqrt((c.i-x)**2+(c.j-y)**2)
                    k = L/r 
                    well_inj = WWIRH[m,c.well].max(dates='all').to_list()[0]
                    w_list_1 = set()
                    w_list_1.add(str(c.well))
                    if well_inj > 0 and w_list_1 & w_list_2 == set():
                        status = 'INJ'
                        w_list_2.add(str(c.well))
                        print(c.well,round(k,1),status,'--',round(r*a,1),round(r,1),file = influence_well_inj)
                    else:
                        status = '#'
                    print(well,c.well,round(k,1),status,'--',round(r*a,1),round(r,1))
#                    print(c.well,round(k,1),status,'--',round(r*a,1),'m',round(r,1),'cells',file = influence_well_inj)
                p_well_2 = c.well   
            influence_well_inj.close()                          
        p_well_1 = c_well

#influence_well_inj.close()
"""
СТУПЕНЬ 2
"""
BHPress = graph (type = 'well', default_value = 0)
RPress = graph (type = 'well', default_value = 0)

for m in get_all_models():
    for w in get_all_wells():
        current_BHP = wbhph[m,w]
        current_RP = WTHPH[m,w]
        observed_BHP = []
        observed_RP = []
        for t in get_all_timesteps():
            if current_BHP[t] > 10 and w.is_opened:
                observed_BHP.append ((t.name, float(current_BHP[t])))
            if current_RP[t] > 10 and w.is_opened:
                observed_RP.append ((t.name, float(current_RP[t])))
        if len (observed_BHP) >= 2:
            BHPress[m,w] = create_table_vs_time(observed_BHP)
        if len (observed_RP) >= 2:
            RPress[m,w] = create_table_vs_time(observed_RP)
export(BHPress, name = 'BHPress')
export(RPress, name = 'RPress')


for m in get_all_models():
    for w in get_wells_by_mask('11735D'):
        influence_well_inj = open(get_project_folder()+'/INCLUDE/skript/influence_well_inj/'+str(w.name)+'.txt','r')
        pressure_diff = open(get_project_folder()+'/INCLUDE/skript/pressure_diff/'+str(w.name)+'.txt','w')
        content = influence_well_inj.readlines()
        content_matrix = [[content[i].split(' ')[j] for j in range(len(content[i].split(' ')))] for i in range(len(content))]
#        for i in range(len(content)):          
#            print(content_matrix[i][0],content_matrix[i][1],content_matrix[i][2])
        for t in get_all_timesteps():
            if WLPRH[m,w,t].to_list()[0] > 0:
                press_diff_koeff = RPress[m,w,t].to_list()[0]/WBP9[m,w,t].to_list()[0]
                WC_diff = WWCTH[m,w,t].to_list()[0]/WWCT[m,w,t].to_list()[0]
                for i in range(len(content)):      
                    well = content_matrix[i][0]
                    for wells in get_wells_by_mask(str(well)):
                        if WWIRH[m,wells,t] > 0:
                            print(t.name,content_matrix[i][0],content_matrix[i][1],round(press_diff_koeff,3),round(WC_diff,3))
#                    print(w.name,t.name,press_diff_koeff)
        influence_well_inj.close()
        pressure_diff.close()
"""
РАЗНИЦА В ДАВЛЕНИЯХ
"""
Res_Press = graph (type = 'well', default_value = 0)
for m in get_all_models():
    for w in get_all_wells():
        current_RP = WTHPH[m,w]
        observed_RP = []
        for t in get_all_timesteps():
            if current_RP[t] > 10 and w.is_opened:
                observed_RP.append ((t.name, float(current_RP[t])))
        if len (observed_RP) >= 2:
            Res_Press[m,w] = create_table_vs_time(observed_RP)
export(Res_Press, name = 'Res_Press')

for w in get_all_wells():
    s1 = 0
    s2 = 0
    for t in get_all_timesteps():
#        print(w.name,t.name,round(float((str(WBP9[w,t]-RP[w,t]).split(' ')[4])),1))
        if w.is_producer()[m,t] == 1:                               #Добывающая скважина
            s1 = s1 + float((str(WBP9[w,t]-RP[w,t]).split(' ')[4]))
        if w.is_producer()[m,t] == 0 and w.is_opened()[m,t] == 1:   #Нагнетательная скважина
            s2 = s2 + float((str(RP[w,t]-WBP9[w,t]).split(' ')[4]))
    print(w.name,round(s1/1000,1),round(s2/1000,1))
    
"""
СКВАЖИНЫ В ДОБЫЧЕ/В ЗАКАЧКЕ
"""
for m in get_all_models():
    for w in get_all_wells():
        for t in get_all_timesteps():
          
#            print(t.name,w.is_producer()[m,t])
            if w.is_producer()[m,t] == 1:
                print(w.name,t.name,'PROD')
            if w.is_producer()[m,t] == 0 and w.is_opened()[m,t] == 1:
                print(w.name,t.name,'INJ')
                
---------------------------------------------------------------------------------------------------------------------------------------------
АДАПТАЦИЯ ДЕПРЕССИИ/ПЛАСТОВОГО ДАВЛЕНИЯ (за весь период)
---------------------------------------------------------------------------------------------------------------------------------------------
from datetime import datetime
from math import sqrt

dict_well_picks = open(get_project_folder()+'/skript/dict/dict_well_picks.txt','r')
dict_well_perf = open(get_project_folder()+'/skript/dict/dict_well_perf.txt','r')
ARR_DEPR_file = open(get_project_folder()+'/skript/ARR_DEPR.txt','w')
dict_res_pressure_file = open(get_project_folder()+'/skript/dict/dict_res_pressure.txt','w')

dict_res_pressure = dict()
well_picks = eval(dict_well_picks.read())
well_perf = eval(dict_well_perf.read())
MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}

RP_h_interp = graph (type = 'well', default_value = 0)
BHP_h_interp = graph (type = 'well', default_value = 0)
for m in get_all_models():
    for w in get_all_wells():
        RP_h_list = []
        BHP_h_list = []
        t1 = c1 = 0
        Press_c_prod_list = []
        Press_c_inj_list = []
        Press_h_prod_list = []
        Press_h_inj_list = []
        avg_res_press_c_list = []
        avg_res_press_h_list = []
        if True:
            for t in get_all_timesteps():
                RP_h = round(wthph[m,w,t].to_list()[0],1)
                RP_c = round(wbp9[m,w,t].to_list()[0],1)
                BHP_h = round(wbhph[m,w,t].to_list()[0],1)
                BHP_c = round(wbhp[m,w,t].to_list()[0],1)
#                print(w.name,t.name,RP_h,RP_c,BHP_h,BHP_c)
                if RP_h > 0:
                    RP_h_list.append((t.to_datetime(),RP_h))
                    if c1 == 0:
                        c1 = 1
                        t1 = datetime.strptime(t.name, "%d.%m.%Y")
                if BHP_h > 0:
                    BHP_h_list.append((t.to_datetime(),BHP_h))
                    if c1 == 0:
                        c1 = 1
                        t1 = datetime.strptime(t.name, "%d.%m.%Y")
            if len(RP_h_list) > 2:
                RP_h_interp[m,w] = create_table_vs_time(RP_h_list)
            if len(BHP_h_list) > 2:
                BHP_h_interp[m,w] = create_table_vs_time(BHP_h_list)
            for t in get_all_timesteps():
                try:
                    if datetime.strptime(t.name, "%d.%m.%Y") < t1:
                        BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
                except TypeError:
                    pass
                if wlprh[m,w,t] == 0 and wwirh[m,w,t] == 0:
                    BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
                else:
                    if BHP_h_interp[m,w,t] > RP_h_interp[m,w,t] and wlprh[m,w,t] > 0:
                        BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
                    if BHP_h_interp[m,w,t] < RP_h_interp[m,w,t] and wwirh[m,w,t] > 0:
                        BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
                        
                if BHP_h_interp[m,w,t] != 0 and RP_h_interp[m,w,t] != 0 and (round(wthph[m,w,t].to_list()[0],1) - round(wbhph[m,w,t].to_list()[0],1)) != 0:
                    if wlprh[m,w,t] > 0:
                        Press_c_prod = round(wbp9[m,w,t].to_list()[0] - wbhp[m,w,t].to_list()[0],1)
                        Press_c_prod_list.append(Press_c_prod)
                        Press_h_prod = round(RP_h_interp[m,w,t].to_list()[0]  - BHP_h_interp[m,w,t].to_list()[0],1) 
                        Press_h_prod_list.append(Press_h_prod)
                        avg_res_press_c_list.append(wbp9[m,w,t].to_list()[0])
                        avg_res_press_h_list.append(RP_h_interp[m,w,t].to_list()[0])                   

#                        print(w.name,'prod',t.name,wlprh[m,w,t].to_list(),Press_c_prod,Press_h_prod)
                    if wwirh[m,w,t] > 0:
                        Press_c_inj = round(wbhp[m,w,t].to_list()[0] - wbp9[m,w,t].to_list()[0],1)
                        Press_c_inj_list.append(Press_c_inj)
                        Press_h_inj = round(BHP_h_interp[m,w,t].to_list()[0] - RP_h_interp[m,w,t].to_list()[0],1)
                        Press_h_inj_list.append(Press_h_inj)  
#                        print(w.name,'inj',t.name,wwirh[m,w,t].to_list(),Press_c_inj,Press_h_inj)

            if len(Press_c_prod_list) >= 10:
                mult_prod = sum(Press_c_prod_list)/sum(Press_h_prod_list)*len(Press_h_prod_list)/len(Press_c_prod_list)
#                print(w.name,'prod',Press_c_prod_list,Press_h_prod_list,round(sum(Press_c_prod_list)/sum(Press_h_prod_list)*len(Press_h_prod_list)/len(Press_c_prod_list),2))
                try:
                    avg_res_press_h = round(sum(avg_res_press_h_list)/len(avg_res_press_h_list),1)
                    avg_res_press_c = round(sum(avg_res_press_c_list)/len(avg_res_press_c_list),1)
                    print('ARR_PRESS',round(avg_res_press_c/avg_res_press_h,2),'/ -- СКВАЖИНА {}'.format(w.name),sep='\t')
                    dict_res_pressure[w.name] = round(avg_res_press_c/avg_res_press_h,2)
#                    print(w.name,'prod',avg_res_press_h,avg_res_press_c,round(mult_prod,3),round(sqrt(mult_prod),3),sep='\t')
                    x = int(well_picks[str(w.name)].split(' ')[0])
                    y = int(well_picks[str(w.name)].split(' ')[1])
                    zone = set(well_perf[w.name])
                    for i in zone:
                        z1 = MODEL_CELLS[i].split(',')[0]
                        z2 = MODEL_CELLS[i].split(',')[1]
                        print('ARR_DEPR',round(sqrt(mult_prod),3),x,x,y,y,z1,z2,'/ -- СКВАЖИНА {}'.format(w.name))
                        print('ARR_DEPR',round(sqrt(mult_prod),3),x,x,y,y,z1,z2,'/ -- СКВАЖИНА {}'.format(w.name),file=ARR_DEPR_file)
                except ValueError:
                    pass
            if len(Press_c_inj_list) >= 10:
                mult_inj = sum(Press_c_inj_list)/sum(Press_h_inj_list)*len(Press_h_inj_list)/len(Press_c_inj_list)
#                print(w.name,'inj',Press_c_inj_list,Press_h_inj_list,round(sum(Press_c_inj_list)/sum(Press_h_inj_list)*len(Press_h_inj_list)/len(Press_c_inj_list),2))
                try:
                    print(w.name,'inj',round(mult_inj,3),round(sqrt(mult_inj),3),sep='\t')
                except ValueError:
                    pass
                
print(dict_res_pressure,file=dict_res_pressure_file)                
export(RP_h_interp, name = 'RP_hist')
export(BHP_h_interp, name = 'BHP_hist')

ARR_DEPR_file.close()
dict_well_picks.close()
dict_well_perf.close()
dict_res_pressure_file.close()
---------------------------------------------------------------------------------------------------------------------------------------------
АДАПТАЦИЯ ПЛАСТОВОГО ДАВЛЕНИЯ (по интервально step)
---------------------------------------------------------------------------------------------------------------------------------------------

from datetime import datetime
from math import sqrt,ceil
step = 5

well_rp_h_dict = dict()
well_rp_c_dict = dict()

t_list = []
for t in get_all_timesteps():
    t_list.append(t.name)
year = int(t_list[0][-4:])
month = t_list[0][-6:-5]
n = ceil((int(t_list[-1][-4:]) - int(t_list[0][-4:]) + (int(t_list[-1][-6:-5]) - int(t_list[0][-6:-5]))/12)/step)
print(t_list[0],t_list[-1],'step: '+str(n),sep='\t')


RP_h_interp = graph (type = 'well', default_value = 0)
BHP_h_interp = graph (type = 'well', default_value = 0)
for m in get_all_models():
    for w in get_all_wells():
        RP_h_list = []
        BHP_h_list = []
        t1 = c1 = 0
        Press_c_prod_list = []
        Press_c_inj_list = []
        Press_h_prod_list = []
        Press_h_inj_list = []
        avg_res_press_c_list = []
        avg_res_press_h_list = []
        if True:
            for t in get_all_timesteps():
                RP_h = round(wthph[m,w,t].to_list()[0],1)
                RP_c = round(wbp9[m,w,t].to_list()[0],1)
                BHP_h = round(wbhph[m,w,t].to_list()[0],1)
                BHP_c = round(wbhp[m,w,t].to_list()[0],1)
                if RP_h > 0:
                    RP_h_list.append((t.to_datetime(),RP_h))
                    if c1 == 0:
                        c1 = 1
                        t1 = datetime.strptime(t.name, "%d.%m.%Y")
                if BHP_h > 0:
                    BHP_h_list.append((t.to_datetime(),BHP_h))
                    if c1 == 0:
                        c1 = 1
                        t1 = datetime.strptime(t.name, "%d.%m.%Y")
            if len(RP_h_list) > 2:
                RP_h_interp[m,w] = create_table_vs_time(RP_h_list)
            if len(BHP_h_list) > 2:
                BHP_h_interp[m,w] = create_table_vs_time(BHP_h_list)
            for t in get_all_timesteps():
                try:
                    if datetime.strptime(t.name, "%d.%m.%Y") < t1:
                        BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
                except TypeError:
                    pass
                if wlprh[m,w,t] == 0 and wwirh[m,w,t] == 0:
                    BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
                else:
                    if BHP_h_interp[m,w,t] > RP_h_interp[m,w,t] and wlprh[m,w,t] > 0:
                        BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
                    if BHP_h_interp[m,w,t] < RP_h_interp[m,w,t] and wwirh[m,w,t] > 0:
                        BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0

for m in get_all_models():
    for i in range(n):
        first_date = datetime.strptime('01.'+month+'.'+str(year+step*i), "%d.%m.%Y")
        last_date = datetime.strptime('01.'+month+'.'+str(year+step*(i+1)), "%d.%m.%Y")
        print('')
        print('well',first_date.strftime("%d.%m.%Y"),last_date.strftime("%d.%m.%Y"),'Pпл_с(t2-t1)/Pпл_h(t2-t1)',sep='\t')
        pressure_file = open(get_project_folder()+'/skript/pressure/P_'+str(year+step*i)+'_'+str(year+step*(i+1))+'.txt','w')
        for w in get_all_wells():  
            for t in get_all_timesteps():            
                if RP_h_interp[m,w,t] != 0:
                    if wlprh[m,w,t] > 0:                           
                        cur_date = datetime.strptime(t.name, "%d.%m.%Y")                                                   
                        if first_date <= cur_date <= last_date:
                            try:
                                well_rp_h_dict[w.name] = well_rp_h_dict[w.name] + RP_h_interp[m,w,t].to_list()[0]
                            except KeyError:
                                well_rp_h_dict[w.name] = RP_h_interp[m,w,t].to_list()[0]
                            try:
                                well_rp_c_dict[w.name] = well_rp_c_dict[w.name] + wbp9[m,w,t].to_list()[0]
                            except KeyError:
                                well_rp_c_dict[w.name] = wbp9[m,w,t].to_list()[0]
                            try:
                                if cur_date == last_date or cur_date == datetime.strptime(t_list[-1], "%d.%m.%Y"):
                                    print(w.name,first_date.strftime("%d.%m.%Y"),last_date.strftime("%d.%m.%Y"),round(well_rp_c_dict[w.name]/well_rp_h_dict[w.name],2),sep='\t')               #запись отношения пластового давления по скважиннам за период времени
                                    print(w.name,round(well_rp_c_dict[w.name]/well_rp_h_dict[w.name],2),sep='\t',file=pressure_file)
#                                    pressure_file.close()     
                                    well_rp_c_dict[w.name] = 0     
                                    well_rp_h_dict[w.name] = 0
                            except KeyError:
                                pass                
export(RP_h_interp, name = 'RP_hist')
export(BHP_h_interp, name = 'BHP_hist')

---------------------------------------------------------------------------------------------------------------------------------------------
ПОИСК ДАТЫ ДЛЯ СКИНА/МУЛЬТА -- ARR_CUT (ДЛЯ АДАПТАЦИИ ПЛАСТОВОГО ДАВЛЕНИЯ)
---------------------------------------------------------------------------------------------------------------------------------------------
import re
from datetime import datetime
start_date = datetime.strptime("01.09.1996", "%d.%m.%Y")

perf_file = open(get_project_folder()+'/skript/data/perf.inc','r')
arr_cut_dict_file = open(get_project_folder()+'/skript/dict/arr_cut_dict.txt','r')
perf_1_file = open(get_project_folder()+'/skript/data/perf_new.inc','w')
arr_cut_dict = eval(arr_cut_dict_file.read())
w_set = set()

def start_inj_date(i_w):
    for m in get_all_models():
        for i_w in get_wells_by_mask(i_w):
            for t in get_all_timesteps():
                if float(wwirh[m,i_w,t].to_list()[0]) > 0:
                    return t.name

perf = perf_file.read()
for k,v in arr_cut_dict.items():
    w_set.add(k)
    i_date = datetime.strptime(start_inj_date(k), "%d.%m.%Y")
#    print(i_date.strftime('%d.%m.%Y'))
    find = re.findall(str(k)+'\t.*'+'--',perf)
    for i in find:
        if i.split('\t')[2] == 'perf':
            if datetime.strptime(i.split('\t')[1], "%d.%m.%Y") < i_date:
                print(i.split('\t')[0],i.split('\t')[1],i.split('\t')[2],i.split('\t')[3],i.split('\t')[4],i.split('\t')[5],i.split('\t')[6],i.split('\t')[7],i.split('\t')[9],sep='\t')
                print(i.split('\t')[0],i.split('\t')[1],i.split('\t')[2],i.split('\t')[3],i.split('\t')[4],i.split('\t')[5],i.split('\t')[6],i.split('\t')[7],i.split('\t')[9],sep='\t',file=perf_1_file)
                print(i.split('\t')[0],i_date.strftime('%d.%m.%Y'),i.split('\t')[2],i.split('\t')[3],i.split('\t')[4],i.split('\t')[5],i.split('\t')[6],v,i.split('\t')[9],sep='\t')
                print(i.split('\t')[0],i_date.strftime('%d.%m.%Y'),i.split('\t')[2],i.split('\t')[3],i.split('\t')[4],i.split('\t')[5],i.split('\t')[6],v,i.split('\t')[9],sep='\t',file=perf_1_file)
            else:
                print(i.split('\t')[0],i.split('\t')[1],i.split('\t')[2],i.split('\t')[3],i.split('\t')[4],i.split('\t')[5],i.split('\t')[6],v,i.split('\t')[9],sep='\t') 
                print(i.split('\t')[0],i.split('\t')[1],i.split('\t')[2],i.split('\t')[3],i.split('\t')[4],i.split('\t')[5],i.split('\t')[6],v,i.split('\t')[9],sep='\t',file=perf_1_file)  
        elif i.split('\t')[2] == 'sque':
            if datetime.strptime(i.split('\t')[1], "%d.%m.%Y") < i_date:
                print(i.split('\t')[0],i.split('\t')[1],i.split('\t')[2],i.split('\t')[3],i.split('\t')[4],i.split('\t')[5],i.split('\t')[6],i.split('\t')[7],i.split('\t')[9],sep='\t')
                print(i.split('\t')[0],i.split('\t')[1],i.split('\t')[2],i.split('\t')[3],i.split('\t')[4],i.split('\t')[5],i.split('\t')[6],i.split('\t')[7],i.split('\t')[9],sep='\t',file=perf_1_file)
                print(i.split('\t')[0],i_date.strftime('%d.%m.%Y'),i.split('\t')[2],i.split('\t')[3],i.split('\t')[4],i.split('\t')[5],i.split('\t')[6],i.split('\t')[7],i.split('\t')[9],sep='\t')
                print(i.split('\t')[0],i_date.strftime('%d.%m.%Y'),i.split('\t')[2],i.split('\t')[3],i.split('\t')[4],i.split('\t')[5],i.split('\t')[6],i.split('\t')[7],i.split('\t')[9],sep='\t',file=perf_1_file)
            else:
                print(i.split('\t')[0],i.split('\t')[1],i.split('\t')[2],i.split('\t')[3],i.split('\t')[4],i.split('\t')[5],i.split('\t')[6],i.split('\t')[7],i.split('\t')[9],sep='\t')   
                print(i.split('\t')[0],i.split('\t')[1],i.split('\t')[2],i.split('\t')[3],i.split('\t')[4],i.split('\t')[5],i.split('\t')[6],i.split('\t')[7],i.split('\t')[9],sep='\t',file=perf_1_file)   


print('-------------------------------------------------------------------')
perf_1_file.close()

perf_1_file = open(get_project_folder()+'/skript/data/perf_new.inc','a')
perf_file = open(get_project_folder()+'/skript/data/perf.inc','r')
perf = perf_file.readlines()

for l in perf:
    well = set()
    well.add(l.split('\t')[0])
    if well & w_set == set() and len(l.split('\t')) >= 8 and l.split('\t')[0]!='--well':

        print(l.split('\t')[0],l.split('\t')[1],l.split('\t')[2],l.split('\t')[3],l.split('\t')[4],l.split('\t')[5],l.split('\t')[6],l.split('\t')[7],l.split('\t')[9].strip(),sep='\t')
        print(l.split('\t')[0],l.split('\t')[1],l.split('\t')[2],l.split('\t')[3],l.split('\t')[4],l.split('\t')[5],l.split('\t')[6],l.split('\t')[7],l.split('\t')[9].strip(),sep='\t',file=perf_1_file)

    else:
        pass

perf_file.close()
perf_1_file.close()
arr_cut_dict_file.close()

---------------------------------------------------------------------------------------------------------------------------------------------
ARR_CUT соединение 2 файлов
---------------------------------------------------------------------------------------------------------------------------------------------
import re
#result = re.sub('@\w+.(\w+)','fuck', 'abc.test@gmail.com, xyz@test.in, test.first@analyticsvidhya.com, first.test@rest.biz')
#print(result)

from math import sqrt
from datetime import datetime

arr_cut_dict_file_new = open(get_project_folder()+'/skript/link_up/arr_cut_dict_new.txt','r')
arr_cut_dict_file_old = open(get_project_folder()+'/skript/link_up/arr_cut_dict_old.txt','r')
arr_cut_dict_file_linked = open(get_project_folder()+'/skript/link_up/arr_cut_dict_linked.txt','w')
perf_file_old = open(get_project_folder()+'/skript/link_up/perf_old.inc','r')
perf_file_new = open(get_project_folder()+'/skript/link_up/perf_new.inc','w')

arr_cut_dict_new = eval(arr_cut_dict_file_new.read())
arr_cut_dict_old = eval(arr_cut_dict_file_old.read())
arr_cut_dict_linked = dict()
perf_old = perf_file_old.read()
perf_add = '\n'

set_new = set(arr_cut_dict_new.keys())
set_old = set(arr_cut_dict_old.keys())

def start_inj_date(i_w):
    for m in get_all_models():
        for i_w in get_wells_by_mask(i_w):
            for t in get_all_timesteps():
                if float(wwirh[m,i_w,t].to_list()[0]) > 0:
                    return t.name

print('ПЕРЕСЕЧЕНИЕ НОВОГО И СТАРОГО МНОЖЕСТВА: ',set_new & set_old)

for well in set_new & set_old:
    mult = round(arr_cut_dict_old[well]*sqrt(arr_cut_dict_new[well]),2)
    arr_cut_dict_linked[well] = mult 
    match = re.findall('{}\t[0-9.]+\tperf\t[0-9.]+\t[0-9.]+\t[0-9.]+\t[0-9.]+\t[0-9.]+\t--'.format(well),perf_old)
    start_date = datetime.strptime(start_inj_date(well), "%d.%m.%Y")
    for m in match:
        m_i = m.split('\t') 
        if datetime.strptime(str(m_i[1]), "%d.%m.%Y") >= start_date:
            perf_old = re.sub(m,str(m_i[0])+'\t'+str(m_i[1])+'\t'+str(m_i[2])+'\t'+str(m_i[3])+'\t'+str(m_i[4])+'\t'+str(m_i[5])+'\t'+str(m_i[6])+'\t'+str(mult)+'\t'+str(m_i[8]),perf_old)

print('ТОЛЬКО НОВОЕ МНОЖЕСТВО: ', set_new - set_old)

for well in set_new - set_old:
    mult = arr_cut_dict_new[well]
    arr_cut_dict_linked[well] = mult 
    match = re.findall('{}\t[0-9.]+\t\w+\t[0-9.]+\t[0-9.]+\t[0-9.]*\t[0-9.]*\t[0-9.]*\t--'.format(well),perf_old)
    start_date = datetime.strptime(start_inj_date(well), "%d.%m.%Y")
    for m in match:
        m_i = m.split('\t')
        if datetime.strptime(str(m_i[1]), "%d.%m.%Y") < start_date and m_i[2]=='perf':
            perf_add = perf_add+str(m_i[0])+'\t'+start_date.strftime('%d.%m.%Y')+'\t'+str(m_i[2])+'\t'+str(m_i[3])+'\t'+str(m_i[4])+'\t'+str(m_i[5])+'\t'+str(m_i[6])+'\t'+str(mult)+'\t'+str(m_i[8])+'\n'
        elif datetime.strptime(str(m_i[1]), "%d.%m.%Y") < start_date and m_i[2]=='sque':
            perf_add = perf_add+str(m_i[0])+'\t'+start_date.strftime('%d.%m.%Y')+'\t'+str(m_i[2])+'\t'+str(m_i[3])+'\t'+str(m_i[4])+'\t'+str(m_i[5])+'\t'+str(m_i[6])+'\t'+str(m_i[7])+'\t'+str(m_i[8])+'\n'
        elif datetime.strptime(str(m_i[1]), "%d.%m.%Y") >= start_date and m_i[2]=='perf':
            perf_old = re.sub(m,str(m_i[0])+'\t'+str(m_i[1])+'\t'+str(m_i[2])+'\t'+str(m_i[3])+'\t'+str(m_i[4])+'\t'+str(m_i[5])+'\t'+str(m_i[6])+'\t'+str(mult)+'\t'+str(m_i[8]),perf_old)    
            
perf_old = perf_old + perf_add

print(perf_old)
print(arr_cut_dict_linked,file=arr_cut_dict_file_linked)
print(perf_old,file=perf_file_new)

arr_cut_dict_file_new.close()
arr_cut_dict_file_old.close()
arr_cut_dict_file_linked.close()
perf_file_old
perf_file_old.close()
perf_file_new.close()
---------------------------------------------------------------------------------------------------------------------------------------------
ФОРМАТИРОВАНИЕ - РАБОТА НА ПЛАСТ
---------------------------------------------------------------------------------------------------------------------------------------------
import re
perf = open(get_project_folder()+'/perf.txt','r')
perf_new = open(get_project_folder()+'perf_new.txt','w')
perf_lines = perf.readlines()
well = ''
plast = ''
data = ''
for l in perf_lines:
    if l.split('\t')[0] == well:
        plast = plast +'+'+ l.split('\t')[1] 
        
    elif l.split('\t')[0] != well:
        if well != '':
            plast_set = set(plast.split('+'))
            plast_list = sorted(list(plast_set))
            plast_str = ' '.join(plast_list)
            print(well,plast_str,data,sep='\t')
            print(well,plast_str,data,sep='\t',file=perf_new)
        plast = l.split('\t')[1] 
        well = l.split('\t')[0]
        data = l.split('\t')[2].strip()
        
perf.close()
perf_new.close()        

---------------------------------------------------------------------------------------------------------------------------------------------
ДЛЯ ИЗМЕНЕИЯ ОФП (На сколько нужно изменить KRWR по скважинно и в общем) / ЗАПИСЬ В СЛОВАРЬ НЕВЯЗКИ ПО ЗОНАМ
---------------------------------------------------------------------------------------------------------------------------------------------
MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}
MAIN = {'100', '101', '10106', '10107', '11700', '11701', '11919', '11920', '11921', '11921D', '11979', '11980', '11981', '11982', '11983', '11984', '11985', '11986', '11987', '11988', '12042', '12043', '12044', '12045', '12233', '12234', '12235', '12236', '12237', '12238', '12239', '12240', '12241', '12242', '13401', '13402', '13403', '13404', '13405', '13406', '13407', '13408', '13409', '13410', '13411', '13412', '13413', '13414', '13415', '13416', '13417', '13418', '13419', '13420', '13421', '13422', '13423', '13424', '13425', '13426', '13427', '13427D', '13428', '13429', '13430', '13431', '13432', '13433', '13434', '13435', '13436', '13437', '13438', '13439', '13440', '13441', '13442', '13444', '13445', '13446', '13448', '13449', '13450', '13451', '13452', '13453', '13454', '13455', '13456', '13457', '13458', '13458D', '13459', '13460', '13461', '13462', '13463', '13464', '13465', '13466', '13467', '13468', '13469', '13470', '13471', '13472', '13473', '13474', '13475', '13476', '13477', '13478', '13479', '13480', '13481', '13483', '13484', '13485', '13486', '13487', '13488', '13489', '13490', '13491', '13492', '13493', '13494', '13495', '13496', '13497', '13498', '13499', '13501', '13503', '13504', '13506', '13507', '13508', '13509', '13510', '13511', '13512', '13513', '13514', '13515', '13516', '13518', '13519', '13520', '13521', '13522', '13523', '13524', '13525', '13526', '13527', '13528', '13529', '13530', '13531', '13532', '13533', '13534', '13535', '13536', '13537', '13538', '13539', '13540', '13541', '13542', '13543', '13544', '13545', '13546', '13547', '13548', '13549', '13550', '13551', '13552', '13553', '13554', '13555', '13556', '13557', '13558', '13559', '13560', '13561', '13563', '13564', '13565', '13566', '13567', '13568', '13569', '13570', '13572', '13573', '13574', '13575', '13576', '13577', '13578', '13579', '13580', '13581', '13582', '13583', '13584', '13585', '13586', '13588', '13589', '13590', '13591', '13592', '13593', '13594', '13595', '13596', '13597', '13598', '13599', '13600', '15113', '15113D', '15114', '16304', '16336', '16482', '16526', '16529', '16530', '16537', '16539', '16540', '16541', '16544', '16547', '17419', '17483', '21292', '21440', '21493', '21502', '21503', '21504', '21505', '21506', '21507', '21508', '21509', '21510', '21511', '21512', '21513', '21514', '21515', '21516', '21517', '21519', '21520', '21521', '21522', '21523', '21524', '21525', '21526', '21527', '21528', '21529', '21530', '21531', '21532', '21533', '21535', '21536', '21537', '21538', '21539', '21540', '21541', '21542', '21543', '21544', '21545', '21546', '21547', '21548', '21550', '21551', '21552', '21553', '21555', '21556', '21557', '21558', '21559', '21560', '21561', '21562', '21563', '21564', '21565', '21566', '21567', '21568', '21569', '21570', '21571', '21572', '21573', '21575', '21576', '21577', '21578', '21579', '21580', '21581', '21582', '21583', '21584', '21587', '21588', '21589', '21590', '21591', '21592', '21593', '21594', '21595', '21596', '21598', '21599', '21600', '21601', '21602', '21603', '21604', '21607', '21608', '21611', '21612', '21614', '21615', '21616', '21617', '21618', '21619', '21620', '21621', '21622', '21625', '21626', '21627', '21629', '21630', '21632', '21633', '21634', '21635', '21636', '21637', '21638', '21640', '21641', '21642', '21643', '21645', '21646', '21647', '21648', '21650', '21651', '21652', '21653', '21654', '21655', '21656', '21658', '21659', '21660', '21661', '21662', '21663', '21664', '21665', '21666', '21667', '21668', '21671', '21672', '21673', '21674', '21675', '21678', '21679', '21680', '21681', '21682', '21683', '21684', '21684A', '21685', '21686', '21687', '21688', '21689', '21691', '21692', '21694', '21696', '21697', '21698', '21699', '21700', '21701', '21702', '21703', '21704', '21705', '21706', '21707', '21708', '21710', '21711', '21712', '21713', '21714', '21715', '21716', '21717', '21718', '21719', '21720', '21721', '21724', '21725', '21726', '21727', '21731', '21732', '21733', '21734', '21735', '21736', '21738', '21740', '21741', '21742', '21743', '21744', '21745', '21746', '21747', '21748', '21750', '21751', '21753', '21755', '21757', '21758', '21759', '21760', '21761', '21762', '21763', '21764', '21765', '21766', '21767', '21768', '21769', '21771', '21772', '21773', '21774', '21775', '21776', '21777', '21778', '21779', '21780', '21781', '21782', '21783', '21784', '21785', '21786', '21787', '21789', '21790', '21791', '21793', '21794', '21796', '21798', '21799', '21800', '25283', '25284', '25285', '25286', '25287', '25288', '25289', '25290', '25293', '25294', '25297', '25298', '25299', '25300', '27303', '27305', '27310', '27315', '27385', '27395', '27481', '27483', '27484', '27487', '32801', '32804', '32805', '32806', '32810', '32813', '32814', '32816', '32817', '32818', '32819', '32820', '32821', '32826', '32827', '32830', '32835', '32836', '32842', '32843', '32844', '32845', '32846', '32854', '32863', '32866', '32868', '32869', '32874', '32875', '32876', '32877', '32878', '32881', '32882', '32883', '32884', '32885', '32886', '32887', '32888', '32889', '32890', '32892', '32893', '32894', '32895', '32896', '32898', '32907', '32910', '32914', '32916', '32917', '32918', '32919', '32920', '32921', '32922', '32923', '32924', '32925', '32929', '32930', '32931', '32940', '32941', '32943', '32947', '32948', '32950', '32954', '32955', '32956', '32957', '32958', '32959', '32960', '3498', '3515', '3516', '3517', '3556', '3557', '3558', '3597', '48', '48D', '49', '5042', '51', '527', '53', '530', '54', '570', '571', '5712', '5713', '5714', '5715', '5716', '5717', '5718', '5719', '5719D', '572', '5720', '5721', '5722', '5722A', '5723', '5724', '5725', '5725A', '5726', '5727', '5728', '5728A', '5729', '5730', '5731', '5731A', '5732', '5733', '5734', '5735', '5736', '5737', '5738', '5739', '5740', '5741', '5741D', '5742', '5743', '5744', '5745', '5746', '5747', '5748', '5749', '5750', '5751', '58', '5801', '5802', '5803', '5804', '5805', '5806', '5806D', '5807', '5807D', '5808', '5809', '5810', '5811', '5811D', '5812', '5813', '5814', '5815', '5815D', '5816', '5816D', '5817', '5818', '5819', '5820', '5821', '5822', '5823', '5824', '5825', '5826', '5827', '5827D', '5828', '5829', '5830', '5831', '5832', '5833', '5834', '5835', '5836', '5837', '5838', '5839', '5840', '5840D', '5841', '5842', '5843', '5844', '5845', '5846', '5847', '5848', '5849', '5850', '5851', '5852', '5853', '5854', '5855', '5856', '5857', '5858', '5859', '5860', '5861', '5862', '5863', '5864', '5864D', '5865', '5865D', '5866', '5867', '5868', '5869', '5870', '5871', '5872', '5873', '5873D', '5874', '5875', '5876', '5877', '5878', '5879', '5880', '5881', '5882', '5883', '5884', '5884D', '5885', '5886', '5887', '5888', '5890', '5891', '5892', '5893', '5894', '5895', '5896', '5897', '5897D', '5898', '5899', '5900', '5901', '5902', '5902D', '5903', '5904', '5905', '5906', '5906D', '5907', '5907D', '5908', '5909', '5909D', '5910', '5911', '5912', '5913', '5913A', '5914', '5915', '5916', '5917', '5918', '5919', '5920', '5921', '5922', '5923', '5924', '5925', '5926', '5927', '5927D', '5928', '5928D', '5929', '5929D', '5930', '5930D', '5931', '5932', '5933', '5934', '5935', '5936', '5937', '5938', '5939', '5940', '5940D', '5941', '5941D', '5942', '5943', '5944', '5945', '5946', '5947', '5947D', '5948', '5949', '5950', '5951', '5952', '5953', '5954', '5955', '5955D', '5956', '5956D', '5957', '5958', '5959', '5960', '5961', '5962', '5963', '5964', '5965', '5966', '5967', '5968', '5969', '5970', '5971', '5972', '5973', '5974', '5975', '5976', '5977', '5978', '5979', '5980', '5981', '5982', '5983', '5984', '5985', '5986', '5987', '5988', '5991', '5992', '5993', '5994', '5995', '5996', '5997', '5998', '5999', '651', '652', '653', '7400', '7401', '7402', '77D', '8000', '8001', '8002', '8002D', '8003', '8004', '8005', '8006', '8007', '8008', '8008D', '8009', '8010', '8011', '8012', '8013', '8014', '8015', '8016', '8017', '8018', '8019', '8020', '8021', '8021D', '8022', '8022D', '8023', '8024', '8025', '8026', '8027', '8028', '8029', '8030', '8031', '8032', '8033', '8034', '8035', '8036', '8037', '8038', '8039', '8040', '8041', '8042', '8043', '8044', '8045', '8046', '8047', '8048', '8049', '8050', '8051', '8052', '8053', '8053B', '8054', '8055', '8056', '8057', '8058', '8059', '8060', '8061', '8062', '8063', '8064', '8065', '8066', '8067', '8068', '8069', '8070', '8071', '8072', '8073', '8074', '8075', '8076', '8077', '8078', '8079', '8080', '8081', '8081D', '8082', '8083', '8084', '8085', '8086', '8087', '8088', '8089', '8090', '8091', '8092', '8093', '8094', '8094D', '8095', '8096', '8097', '8098', '8099', '8100', '8101', '8102', '8103', '8104', '8106', '8107', '8108', '8109', '8110', '8111', '8112A', '8113', '8114', '8115', '8116', '8117', '8118', '8119', '8120', '8121', '8122', '8123', '8124', '8125', '8127', '8128', '8129', '8131', '8132', '8133', '8134', '8135', '8136', '8137', '8138', '8139', '8140', '8141', '8141D', '8142', '8143', '8144', '8145', '8146', '8147', '8148A', '8149', '8150', '8151', '8152', '8153', '8154', '8155', '8156', '8157', '8158', '8159', '8160', '8161', '8162', '8162D', '8163', '8164', '8165', '8166', '8167', '8168', '8168D', '8169', '8170', '8171', '8172', '8173', '8174', '8175', '8176', '8177', '8178', '8179', '8180', '8181', '8182', '8183', '8184', '8185', '8186', '8187', '8188', '8189', '8190', '8191', '8192', '8193', '8194', '8195', '8196', '8197', '8198', '8198D', '8199', '8200', '84', '84D'}
count = dict()
dict_well_ROP_file = dict()

'''
i = 'vars'
mult = 123
exec('str_{} = {}'.format(i,mult))
print(eval('str_{}'.format(i)))
'''

for k,v in MODEL_CELLS.items():
    dict_well_ROP_file[k] = open(get_project_folder()+'/skript/dict/dict_well_ROP_zone_'+k+'.txt','w')  
    exec('dict_well_ROP_{} = dict()'.format(k))

for m in get_all_models():
    if flpth[m].max(dates='all') > 0:
        d_model = dict()
        for w in get_all_wells():
            well = set()
            well.add(w.name)
            if wlpth[m,w].max(dates='all') > 0 and MAIN & well != set():
                d_well_oil_h = dict()
                d_well_oil_c = dict()
    #            d_well_wat_h = dict()
    #            d_well_wat_c = dict()
                for t in get_all_timesteps():
                    d_inter = dict()
                    for c in w.connections:
                        for key,val in MODEL_CELLS.items():
                            if clpr[m,c,t].to_list()[0] != 0 and int(val.split(',')[0]) <= int(c.k) <= int(val.split(',')[1]):
    #                            print(w.name,c.k,t.name,round(clpr[m,c,t].to_list()[0],1))
                                try:
                                    d_inter[key] = d_inter[key] + clpr[m,c,t].to_list()[0]
                                except KeyError:
                                    d_inter[key] = clpr[m,c,t].to_list()[0]
                    if len(d_inter) == 1:
                        for k,v in d_inter.items():
                            key = k
    #                    print(d_inter,round(wopr[m,w,t].to_list()[0],1),round(woprh[m,w,t].to_list()[0],1),key)
                        try:
                            d_well_oil_h[key] = d_well_oil_h[key] + (woprh[m,w,t]*weff[m,w,t]).to_list()[0]
                        except KeyError:
                            d_well_oil_h[key] = (woprh[m,w,t]*weff[m,w,t]).to_list()[0]
                        try:
                            d_well_oil_c[key] = d_well_oil_c[key] + (wopr[m,w,t]*weff[m,w,t]).to_list()[0]
                        except KeyError:
                            d_well_oil_c[key] = (wopr[m,w,t]*weff[m,w,t]).to_list()[0]
                for k,v in d_well_oil_h.items():
                    try:
                        mult = round(d_well_oil_c[k]/v,3)
                        exec('dict_well_ROP_{}[w.name] = {}'.format(k,mult))
                        print(w.name,k,mult,sep='\t')
                        d_model[k] = d_model[k] + d_well_oil_c[k]/v
                        count[k] = count[k] + 1
                    except ZeroDivisionError:
                        print('ZeroDivisionError',w.name,k,d_well_oil_c[k],v)
                    except KeyError:
                        d_model[k] = d_well_oil_c[k]/v
                        count[k] = 1
        print('\nSUMMARY')
        for k,v in d_model.items():
            print('zone',k,'KRWR',round(v/count[k],3),'count',count[k],sep='\t')
            
for k,v in MODEL_CELLS.items():
    print(eval('dict_well_ROP_{}'.format(k)),file=dict_well_ROP_file[k])

---------------------------------------------------------------------------------------------------------------------------------------------
ДЛЯ ИЗМЕНЕНИЯ ПЛАСТОВОГО ДАВЛЕНИЯ (НА КАКИЕ ПЛАСТЫ НУЖНО ИЗМЕНИТЬ ПЛАСТОВОЕ ДАВЛЕНИЕ, ЧТОБЫ ВЫРОВНИТЬ ПРОФИЛЬ ПРИТОКА) (не дописан)
---------------------------------------------------------------------------------------------------------------------------------------------
MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}

MODEL_CELLS_set = {k:{int(i) for i in range(int(v.split(',')[0]),int(v.split(',')[1])+1 )} for k,v in MODEL_CELLS.items()}
for k in MODEL_CELLS.keys():
    exec('BHP_h_list_{} = dict()'.format(k))
    exec('BHP_c_list_{} = dict()'.format(k))
    exec('RP_h_list_{} = dict()'.format(k))
    exec('RP_c_list_{} = dict()'.format(k))
    exec('count_{} = dict()'.format(k))

from datetime import datetime
from math import sqrt,ceil

RP_h_interp = graph (type = 'well', default_value = 0)
BHP_h_interp = graph (type = 'well', default_value = 0)
for m in get_all_models():
    for w in get_all_wells('51'):

#        exec('BHP_h_list_{} = dict()'.format(w.name))
#        exec('BHP_c_list_{} = dict()'.format(w.name))
#        exec('RP_h_list_{} = dict()'.format(w.name))
#        exec('RP_c_list_{} = dict()'.format(w.name))
        RP_h_list = []
        BHP_h_list = []
        t1 = c1 = 0
        for t in get_all_timesteps():
            RP_h = round(wthph[m,w,t].to_list()[0],1)
            RP_c = round(wbp9[m,w,t].to_list()[0],1)
            BHP_h = round(wbhph[m,w,t].to_list()[0],1)
            BHP_c = round(wbhp[m,w,t].to_list()[0],1)
            if RP_h > 0:
                RP_h_list.append((t.to_datetime(),RP_h))
                if c1 == 0:
                    c1 = 1
                    t1 = datetime.strptime(t.name, "%d.%m.%Y")
            if BHP_h > 0:
                BHP_h_list.append((t.to_datetime(),BHP_h))
                if c1 == 0:
                    c1 = 1
                    t1 = datetime.strptime(t.name, "%d.%m.%Y")
            if len(RP_h_list) > 2:
                RP_h_interp[m,w] = create_table_vs_time(RP_h_list)
            if len(BHP_h_list) > 2:
                BHP_h_interp[m,w] = create_table_vs_time(BHP_h_list)
                
        for t in get_all_timesteps():
            try:
                if datetime.strptime(t.name, "%d.%m.%Y") < t1:
                    BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
            except TypeError:
                pass
            if wlprh[m,w,t] == 0 and wwirh[m,w,t] == 0:
                BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
            else:
                if BHP_h_interp[m,w,t] > RP_h_interp[m,w,t] and wlprh[m,w,t] > 0:
                    BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
                if BHP_h_interp[m,w,t] < RP_h_interp[m,w,t] and wwirh[m,w,t] > 0:
                    BHP_h_interp[m,w,t] = RP_h_interp[m,w,t] = 0
                    
        for t in get_all_timesteps():
            con = []
            for c in w.connections:
                if clpr[m,c,t].to_list()[0] != 0:
                    con.append(c.k)
#            print(con)
            count = 0
            for k,v in MODEL_CELLS_set.items():
                if set(con) & set(v):
                    count += 1
                    zone = k
            if count == 1 and BHP_h_interp[m,w,t] != 0 and RP_h_interp[m,w,t] != 0 and wbp9[m,w,t].to_list()[0] != 0 and wbhp[m,w,t].to_list()[0] != 0:
#                print(w.name,t.name,zone)
                try:
                    exec('BHP_h_list_{}[w.name] = BHP_h_list_{}[w.name] + BHP_h_interp[m,w,t]'.format(zone,zone))
                    exec('BHP_c_list_{}[w.name] = BHP_c_list_{}[w.name] + wbp9[m,w,t].to_list()[0]'.format(zone,zone))
#                    exec('RP_h_list_{}[w.name] = RP_h_list_{}[w.name] + RP_h_interp[m,w,t]'.format(zone,zone))
#                    exec('RP_c_list_{}[w.name] = RP_c_list_{}[w.name] + wbhp[m,w,t].to_list()[0]'.format(zone,zone))
                    exec('count_{}[w.name] += int(1)'.format(k))
#                    print(w.name,t.name,eval('count_{}[w.name]'.format(k)),zone)
                except KeyError:
                    exec('BHP_h_list_{}[w.name] = BHP_h_interp[m,w,t]'.format(zone))
                    exec('BHP_c_list_{}[w.name] = wbp9[m,w,t].to_list()[0]'.format(zone))
#                    exec('RP_h_list_{}[w.name] = RP_h_interp[m,w,t]'.format(zone))
#                    exec('RP_c_list_{}[w.name] = wbhp[m,w,t].to_list()[0]'.format(zone))   
                    exec('count_{}[w.name] = 1'.format(k))
#                    print(w.name,t.name,eval('count_{}[w.name]'.format(k)),zone)
        for k in MODEL_CELLS_set.keys():
            try:
#                if exec('count_{}[w.name]>=5'.format(k)):
#                print(w.name,'BHP_h',eval('BHP_h_list_{}[w.name]/count_{}[w.name]'.format(k,k)))     
                print(w.name,k,round(eval('BHP_c_list_{}[w.name]/BHP_h_list_{}[w.name]'.format(k,k)).to_list()[0],3),(eval('count_{}[w.name]'.format(k))))  
#                print(w.name,'RP_h',eval('RP_h_list_{}[w.name]/count_{}[w.name]'.format(k,k)))    
#                print(w.name,'RP_c',eval('RP_c_list_{}[w.name]/RP_h_list_{}[w.name]'.format(k,k)))           
            except KeyError:
                print('pass',w.name,k)
                pass
        
                
#                for k,v in MODEL_CELLS.items():
#                    if clpr[m,c,t].to_list()[0] != 0 and int(v.split(',')[0]) <= int(c.k) <= int(v.split(',')[1]):
#                        zone[k][m,w,t] = int(k)
       
export(RP_h_interp, name = 'RP_hist')
export(BHP_h_interp, name = 'BHP_hist')
                

---------------------------------------------------------------------------------------------------------------------------------------------
ВИЗУАЛИЗАЦИЯ (на какие пласты работает)
---------------------------------------------------------------------------------------------------------------------------------------------
MODEL_CELLS = {'1': '1,16','2': '18,49', '3': '51,179'}
zone = dict()

for k, v in MODEL_CELLS.items():
    zone[k] = graph (type = 'well', default_value = 0)

for m in get_all_models():
    if flpth[m].max(dates='all') > 0:
        for w in get_all_wells():
            if wlpth[m,w].max(dates='all') > 0 or wwith[m,w].max(dates='all') > 0:
                for t in get_all_timesteps():
#                    d_inter = dict()
                    for c in w.connections:
                        for k,v in MODEL_CELLS.items():
                            if (clpr[m,c,t].to_list()[0] != 0 or cwir[m,c,t].to_list()[0] != 0) and int(v.split(',')[0]) <= int(c.k) <= int(v.split(',')[1]):
                                zone[k][m,w,t] = int(k)


for k, v in MODEL_CELLS.items():
    export(zone[k], name = 'zone_'+k)


